<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Ying&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Ying&#39;s Blog">
<meta property="og:url" content="https://echo557.github.io/echoblog.github.io/page/11/index.html">
<meta property="og:site_name" content="Ying&#39;s Blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ying&#39;s Blog">
  
    <link rel="alternate" href="/echoblog.github.io/atom.xml" title="Ying&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/echoblog.github.io/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/echoblog.github.io/" id="logo">Ying&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/echoblog.github.io/">Home</a>
        
          <a class="main-nav-link" href="/echoblog.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/echoblog.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://echo557.github.io/echoblog.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-MYSQL-Study5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/echoblog.github.io/2019/01/26/MYSQL-Study5/" class="article-date">
  <time datetime="2019-01-26T01:50:15.000Z" itemprop="datePublished">2019-01-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/echoblog.github.io/categories/MYSQL/">MYSQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/echoblog.github.io/2019/01/26/MYSQL-Study5/">索引下</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/echoblog.github.io/2019/01/26/MYSQL-Study5/索引示意图.png" alt="(name,age)索引示意图"><br><img src="/echoblog.github.io/2019/01/26/MYSQL-Study5/InnoDB索引结构.png" alt="InnoDB索引示意图"><br><img src="/echoblog.github.io/2019/01/26/MYSQL-Study5/图三.png" alt="图三"><br><img src="/echoblog.github.io/2019/01/26/MYSQL-Study5/图四.png" alt="图四"><br><img src="/echoblog.github.io/2019/01/26/MYSQL-Study5/索引（下）.png" alt="索引（下）"></p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h4 id="如果执行select-from-T-where-k-between-3-and-5-需要执行几次树的搜索操作，-会扫描多少行？"><a href="#如果执行select-from-T-where-k-between-3-and-5-需要执行几次树的搜索操作，-会扫描多少行？" class="headerlink" title="如果执行select * from T where k between 3 and 5, 需要执行几次树的搜索操作， 会扫描多少行？"></a>如果执行select * from T where k between 3 and 5, 需要执行几次树的搜索操作， 会扫描多少行？</h4><h4 id="初始化语句：-create-table-T-ID-int-primary-key-k-int-not-null-default-0-s-varchar-16-not-null-default-‘’-indec-k-k-engine-InnoDB"><a href="#初始化语句：-create-table-T-ID-int-primary-key-k-int-not-null-default-0-s-varchar-16-not-null-default-‘’-indec-k-k-engine-InnoDB" class="headerlink" title="初始化语句： create table T(ID int primary key, k int not null default 0, s varchar(16) not null default ‘’, indec k(k)) engine = InnoDB;"></a>初始化语句： create table T(ID int primary key, k int not null default 0, s varchar(16) not null default ‘’, indec k(k)) engine = InnoDB;</h4><h4 id="insert-into-T-values-100-1-‘aa’-200-2-’bb’-300-3-’cc’-500-5-’ee’-600-6-’ff’-700-7-’gg’"><a href="#insert-into-T-values-100-1-‘aa’-200-2-’bb’-300-3-’cc’-500-5-’ee’-600-6-’ff’-700-7-’gg’" class="headerlink" title="insert into T values(100,1, ‘aa’),(200,2,’bb’),(300,3,’cc’),(500,5,’ee’),(600,6,’ff’),(700,7,’gg’);"></a>insert into T values(100,1, ‘aa’),(200,2,’bb’),(300,3,’cc’),(500,5,’ee’),(600,6,’ff’),(700,7,’gg’);</h4><h3 id="SQL执行流程"><a href="#SQL执行流程" class="headerlink" title="SQL执行流程"></a>SQL执行流程</h3><ul>
<li>在k索引树上找到k=3的记录，取得ID=300</li>
<li>再到ID索引树查到ID=300对应的R3</li>
<li>在k索引树取下一个值k=5， 取得ID=500</li>
<li>再回到ID 索引树查到ID=500对应的R4</li>
<li>在k索引树取下一个值k=6， 不满足条件，循环结束</li>
</ul>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><ul>
<li>如果执行语句select ID from T where k between 3 and 5， 这时候只需要查ID的值， 而ID 的值已经在k索引树上，因此可以直接提供查询结果，不需要回表。在这个查询里面，索引k已经“覆盖了”我们的查询需求，称为覆盖索引</li>
<li>需要注意的是， 在引擎内部使用覆盖索引在索引k上其实读了3个记录，R3~R5(对应的索引k上的记录项)，但是对于mysql 的server 层来说，它就是找引擎拿到两条记录，因此mysql 认为扫描行数是2</li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>减少树的搜索次数， 显著提升查询性能， 所以使用覆盖索引是一个常用的性能优化手段</li>
</ul>
<h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><ul>
<li>在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？</li>
<li>Create table ‘tuser’(‘id’ int(11) not null, ‘id_card’ varchar(32) default null, ‘name’ varchar(32) default null, ‘age’ int(11) default null, ‘ismale’ tinyint(1) default null, primary key (‘id’), key ‘id_card’ (‘id_card’), key ‘name_age’ (‘name’, ‘age’) ) ENGINE = InnoDB</li>
<li>根据身份证号查询市民信息的需求，我们只需要在身份证号字段上建立索引就够，在建立一个（身份证，姓名）的联合索引，岂不是浪费空间？</li>
<li>如果现在有一个高频请求，要根据身份证号查询姓名，这个联合索引就有意义。它可以在高频请求上用到覆盖索引， 不在需要需要回表查正航记录</li>
</ul>
<h2 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h2><h3 id="引子-1"><a href="#引子-1" class="headerlink" title="引子"></a>引子</h3><ul>
<li>B+树这种索引结构，可以利用索引的“最左前缀”， 来定位记录</li>
<li>如（name,age）索引示意图， 可以看到索引项是按照索引定义里面出现的字段顺序排序的。</li>
<li>当逻辑需求是查到所有名字是“张三”时，可以快速定位到ID4， 然后遍历得到所有需要的结果</li>
<li>如果要查询所有名字第一个字是“张”， SQL 语句就是“where name like ‘张%’”。此时，可以查到第一个符合条件的记录是ID3， 然后向后遍历，直到不满足条件为止</li>
</ul>
<h3 id="讨论-1"><a href="#讨论-1" class="headerlink" title="讨论"></a>讨论</h3><ul>
<li>在建立联合索引时， 如何安排索引内的字段顺序</li>
<li>评估标准： 索引的复用能力。 </li>
<li>第一原则， 如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的</li>
<li>那么，如果既有联合查询，又有基于a,b各自的查询呢？查询条件里面只有b语句，时无法使用(a,b)这个联合索引的，这时候不得不维护另外一个索引，即（a,b）, (b)这两个</li>
<li>空间原则： 如上面的市民表， name 字段大于age 字段，则建议创建一个（name, age）的联合索引和一个（age）的单字段索引</li>
</ul>
<h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><h3 id="引子-2"><a href="#引子-2" class="headerlink" title="引子"></a>引子</h3><ul>
<li>如果满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。 如果不符合最左前缀的部分，怎样处理呢？</li>
<li>如上面的连个索引（name, age）为例。需求： 检索表中“名字第一个字是张，而且年龄是10 的所有男孩”。 SQL：select * from tuser where name like ‘张%’ and age=10 and ismale =1;</li>
<li><p>执行步骤</p>
<ul>
<li>满足第一个条件，找到记录ID=3</li>
<li>在MySQL 5.6 之前，只能从ID3 开始一个个回表，到主键索引上找出数据行，再对比字段值</li>
<li>MYSQL 5.6 引入索引下推优化， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</li>
<li>图三和图四是两个过程的流程图，每一个虚线箭头表示回表一次</li>
<li>图3中，（name,age）索引里面去掉了age的值， 这个过程InnoDB 并不去去看age的值， 值是按顺序把“name第一个字是张”的记录一条条取出来回表。因此需要回表4次。</li>
<li>图4跟图3的区别是： InnoDB 在（name,age）索引内部就判断了age 是否为10， 对于不为10的记录，直接判断并跳过。则需要回表2次</li>
</ul>
</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><h3 id="覆盖索引-1"><a href="#覆盖索引-1" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><ul>
<li>select ID from T where k between 3 and 5</li>
</ul>
<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><ul>
<li>select ID from T where name like ‘张%’</li>
</ul>
<h3 id="索引下推-1"><a href="#索引下推-1" class="headerlink" title="索引下推"></a>索引下推</h3><ul>
<li>select * from tuser where name like ‘张%’ and age=10 and ismale =1;</li>
</ul>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><h3 id="实际上主键索引也是可以使用多个字段的"><a href="#实际上主键索引也是可以使用多个字段的" class="headerlink" title="实际上主键索引也是可以使用多个字段的"></a>实际上主键索引也是可以使用多个字段的</h3><h3 id="如表定义：-create-table-‘geek’-‘a’-int-11-not-null-‘b’-int-11-not-null-‘c’-int-11-not-null-‘d’-int-11-not-null-primary-key-‘a’-‘b’-key-‘c’-‘c’-key-‘ca’-‘c’-’a’-key-‘cb’-‘c’-‘b’-ENGINE-InnoDB"><a href="#如表定义：-create-table-‘geek’-‘a’-int-11-not-null-‘b’-int-11-not-null-‘c’-int-11-not-null-‘d’-int-11-not-null-primary-key-‘a’-‘b’-key-‘c’-‘c’-key-‘ca’-‘c’-’a’-key-‘cb’-‘c’-‘b’-ENGINE-InnoDB" class="headerlink" title="如表定义： create table ‘geek’(‘a’ int(11) not null, ‘b’ int(11) not null, ‘c’ int(11) not null, ‘d’ int(11) not null, primary key (‘a’, ‘b’), key ‘c’ (‘c’), key ‘ca’ (‘c’,’a’), key ‘cb’ (‘c’, ‘b’))ENGINE = InnoDB;"></a>如表定义： create table ‘geek’(‘a’ int(11) not null, ‘b’ int(11) not null, ‘c’ int(11) not null, ‘d’ int(11) not null, primary key (‘a’, ‘b’), key ‘c’ (‘c’), key ‘ca’ (‘c’,’a’), key ‘cb’ (‘c’, ‘b’))ENGINE = InnoDB;</h3><h3 id="这个表需要a-b-做连个主键索引，-但为什么还有‘ca’，‘cb’两个索引呢？"><a href="#这个表需要a-b-做连个主键索引，-但为什么还有‘ca’，‘cb’两个索引呢？" class="headerlink" title="这个表需要a,b 做连个主键索引， 但为什么还有‘ca’，‘cb’两个索引呢？"></a>这个表需要a,b 做连个主键索引， 但为什么还有‘ca’，‘cb’两个索引呢？</h3><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><ul>
<li>主键a,b的聚簇索引组织顺序相当于order by a,b,也就是按a排序， 再按b排序，c 无序</li>
<li>索引ca的组织是先按c排序，再按a排序， 同时记录主键（注意，这里不是ab， 而是只有b。 这个跟索引c的数据是一模一样的</li>
<li>索引cb的组织是先按c排序，再按b排序，同时记录主键a</li>
<li>因此 ca 可以去掉， cb需要保留</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://echo557.github.io/echoblog.github.io/2019/01/26/MYSQL-Study5/" data-id="ck1jd1wl3001b4kvxl2sly241" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/echoblog.github.io/tags/QA/">QA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LinuxCommand" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/echoblog.github.io/2019/01/20/LinuxCommand/" class="article-date">
  <time datetime="2019-01-20T13:50:25.000Z" itemprop="datePublished">2019-01-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/echoblog.github.io/categories/Operation-System/">Operation System</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/echoblog.github.io/2019/01/20/LinuxCommand/">Linux Command</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Basic-Command"><a href="#Basic-Command" class="headerlink" title="Basic Command"></a>Basic Command</h3><p>系统信息<br>arch<br>uname -m<br>cat /proc/cpuinfo<br>data</p>
<p>文件搜索<br>find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录<br>find / -user user1 搜索属于用户 ‘user1’ 的文件和目录<br>find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件<br>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://echo557.github.io/echoblog.github.io/2019/01/20/LinuxCommand/" data-id="ck1jd1wkr000w4kvxbeq3i0ln" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/echoblog.github.io/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MYSQL-Study4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/echoblog.github.io/2019/01/07/MYSQL-Study4/" class="article-date">
  <time datetime="2019-01-07T12:46:59.000Z" itemprop="datePublished">2019-01-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/echoblog.github.io/categories/MYSQL/">MYSQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/echoblog.github.io/2019/01/07/MYSQL-Study4/">索引上</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="索引上"><a href="#索引上" class="headerlink" title="索引上"></a>索引上</h3><p>索引是为了提高数据库查询的效率， 就像书的目录一样。</p>
<h4 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h4><p>可以用于提高读写效率的数据结构很多，常见的三种数据结构有： 哈希表、有序数组 和搜索树。<br>区别：</p>
<ol>
<li>哈希表是一种以键值对（key-value）存储数据的结构，我们只需要输入待查找的值key, j就能找到对应的值value。 哈希的思路： 把值放在数组里， 用一个哈希函数<br>把key 换算成一个确定的位置， 然后把value放在数组的这个位置。<br>不可避免地， 多个key值经过hash 函数地转换，会出现同一个值得情况。处理这种情况得一种方法是： 拉出一个链表。<br>如一个需要维护得身份证信息和姓名得表，需要根据身份证号找到对应名字，哈希索引示意图：</li>
</ol>
<p><img src="/echoblog.github.io/2019/01/07/MYSQL-Study4/hash.png" alt="Hash"><br>图中，User2 和User4根据身份证号算出来得值都是N，但是没关系，后面还有个链表。<br>若你要查出ID_card_n2对应得name,step： 将ID_card_n2通过hash function 算出N， 然后顺序遍历，找到user2.</p>
<p>主要注意得是， 图中四个ID_card_n得值并不是递增得，这样得好处是增加新user时速度会很快，只需要往后追加。 缺点是： 因为不是有序，<br>所以哈希索引做区间查询得速度是很慢的。<br>所以，哈希表这种结构适用于只有等值查询的场景。 如Memcached 及其他一些NoSQL 引擎。</p>
<ol start="2">
<li>而有序数组在等值查询和范围查询场景中的性能就都非常优秀。 如下图：<br><img src="/echoblog.github.io/2019/01/07/MYSQL-Study4/order.png" alt="Order"></li>
</ol>
<p>假设身份证号没有重复，此数组就是按照身份证号递增的顺序保存的。这时候要查ID_card_n2 对应的名字， 用二分法就可以很快速得到， 时间复杂度是O(LOG(N)).</p>
<p>同时很显然，这个索引结构支持范围查询。 若要查询身份证号在[ID_card_X, ID_card_Y]区间的User, 可以先用二分法找到ID_card_X(<br>如果不存在ID_card_X， 就找到大于ID_card__X的第一个User)， 然后向右遍历， 直到找到第一个大于ID_card_Y 的身份证号，退出循环。</p>
<p>仅看查询效率，有序数组是最好的数据结构。 但更新需要挪动后面所有记录，成本太高。<br>所以，有序数组索引只适用于静态存储引擎， 那些不再修改的数据。</p>
<ol start="3">
<li>二叉搜索树，同样例子如图：<br><img src="/echoblog.github.io/2019/01/07/MYSQL-Study4/tree.png" alt="Tree"></li>
</ol>
<p>二叉搜索树的特点： 每个节点的左儿子小于父节点， 父节点又小于右儿子。 若要查询ID_card_n2的话， 按照图中搜索顺序就是按照UserA&gt;UserC&gt;UserF&gt;User2此路径<br>得到。 这个时间复杂成都是O（log(N)）。</p>
<p>当然为了维持O（log(N)）的查询复杂度， 就需要平衡二叉树， 为了保证这个，更新时间复杂度也是O（log(N)）。</p>
<p>树可以有二叉， 也可以有多叉。 多叉树就是每个节点有多个儿子，儿子之间大小从左到右递增。二叉树的搜索效率是最高的。但是实际上<br>大多数数据库存储却并不使用二叉树。 原因是： 索引不止存在内存中，还要写到磁盘里。</p>
<p>若一颗100万节点的平衡二叉树，树高20.一次查询可能需要访问20个数据块。在机械硬盘时代，从磁盘随机读一个数据库需要10ms 左右的寻址时间。 对于<br>100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10ms。</p>
<p>为了让一个查询尽量少读磁盘，就必须让查询过程访问尽量少的数据块。所以，应该使用N叉树。这里， N叉树中的N取决于数据块大小。 </p>
<p>以InnoDB 为例， N大概是1200. 树高为4的时候，可以存储1200的3次方个值，为17亿。 考虑到树根的数据块总是在内存中，一个<br>10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3此磁盘。 其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了</p>
<p>N叉树由于读写上的性能优点，以及适配磁盘的访问模式。已经被广泛应用在数据库引擎中。<br>跳表、LSM树等数据结构也被用于引擎设计中。</p>
<p>数据库底层存储核心是基于数据库模型的。<br>在MYSQL 中， 索引是在存储引擎层实现的，所以并没有统一索引标准，即不同才存储引擎的索引工作方式并不一样。</p>
<h3 id="InnoDB索引模型"><a href="#InnoDB索引模型" class="headerlink" title="InnoDB索引模型"></a>InnoDB索引模型</h3><p>在InnoDB中， 表是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。 InnoDB使用了B+树索引模型，<br>所以数据是存储在B+树中的。 每个索引在InnoDB里面对应一颗B+树。<br>若， 我们有一个主键列为ID的值， 表中有字段K， 并且在K 上有索引。<br>建表语句：<br>create table T(<br>id int primary key,<br>k int not null,<br>name varchar(16),<br>index (k))engine = InnoDB;</p>
<p>表中R1-R5的(ID,k)值分别为（100,1）,(200,2),(300,3),(400,4),(500,5)和(600,6)， 两棵树示例如下：<br><img src="/echoblog.github.io/2019/01/07/MYSQL-Study4/InnoDB.png" alt="InnoDB Example"></p>
<p>根据叶子节点的内容，索引类型分为主键索引 和非主键索引。 主键索引的叶子节点存的是整行数据， 在InnoDB里，<br>主键索引也被称为聚簇索引（clustered index）。 非主键索引的叶子节点内容是主键的值。 在InnoDB中，非<br>主键索引也称为二级索引（secondary index）。</p>
<p>基于主键索引和普通索引的查询区别：</p>
<ol>
<li>如果语句是select * from T where ID=500, 即主键查询方式，则只需要搜索ID 这颗B+树。</li>
<li>如果语句是 select * from T where k=5， 即普通索引查询方式，则需要先搜索k索引树， 得到ID 的<br>值为500， 再到ID 索引树搜索一次。 此过程叫回表。</li>
</ol>
<p>因此我们再应用中应尽量使用主键查询。</p>
<h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><p>B+ 树为了索引有序性， 在插入新值得时候需要做必要得维护。<br>以上图为例，如果插入新的行ID 值为700， 则只需要在R5的记录后面插入一个新记录。如果新插入的ID 值为400，<br>就相对麻烦，需要逻辑上挪动后面的数据，空出位置。更糟糕的是，如果R5 所在数据页已经满了，根据B+树的算法，<br>这时候就需要申请一个新的数据页，然后挪动部分数据过去。此过程叫页分裂，这种状况下啊，性能就会受到影响。</p>
<p>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。<br>当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p>
<p>基于上面索引维护过程说明，可以做以下讨论：<br>可能在一些建表规范中见过类似描述， 要求建表语句里一定要有自增主键。那么可以分析以下哪些场景下应该使用自增主键，哪些不该。</p>
<p>自增主键： 自增列上定义的主键，在建表语句中一般定义：NOT NULL PRIMARY KEY AUTO_INCREMENT<br>插入新记录的时候可以不指定ID 值， 系统会获取当前ID最大值加1作为下一条记录的ID 值。<br>即， 自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，<br>都不涉及到挪动其他记录，也不会触及到叶子节点的分裂。</p>
<p>而有业务逻辑的字段做主键则往往不容易保证有序插入，这样写数据成本相对较高。</p>
<p>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证做主键，那么每个二级索引的叶子节点占用约20个字节，如果整型做<br>主键，则只要4个字节，如果长整型(bigint)则是8个字节。</p>
<p>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</p>
<p>所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。</p>
<p>有没有什么场景适合用业务字段直接做主键的呢？ 如：有些业务场景需求是：</p>
<ol>
<li>只有一个索引</li>
<li>该索引必须是唯一索引<br>KV场景</li>
</ol>
<p>需要尽量使用主键查询原则，直接将索引设置为主键，可以避免每次搜索两棵树。</p>
<h4 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h4><p>通过两个alter 语句重建索引k,以及通过两个alter 语句重建主键索引是否合理。</p>
<p>为什么要重建索引？<br>索引可能因为删除，或者页分裂等原因，导致数据页有空洞， 重建索引的过程会创建一个新的索引，把数据按顺序插入，可以让页面利用率最高。</p>
<p>重建索引k的做法是合理的，可以达到省空间的目的。但是，重建主键的过程不合理。 不论是删除主键还是创建主键，都会将整个表重建。<br>所以连着执行两个语句，第一个语句就会白做。所以可以用语句代替： alter table T engine=InnoDB</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://echo557.github.io/echoblog.github.io/2019/01/07/MYSQL-Study4/" data-id="ck1jd1wl000174kvx0qvtc3z4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/echoblog.github.io/tags/QA/">QA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MYSQL-Study3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/echoblog.github.io/2019/01/01/MYSQL-Study3/" class="article-date">
  <time datetime="2019-01-01T09:42:59.000Z" itemprop="datePublished">2019-01-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/echoblog.github.io/categories/MYSQL/">MYSQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/echoblog.github.io/2019/01/01/MYSQL-Study3/">隔离</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>####　事务隔离<br>事务是保证一组数据库操作，要么全部成功，要么全部失败。　在ＭySQA中，事务支持是在引擎层实现的。MySQL是一个支持多引擎的系统，<br>但并不是所有的引擎都支持事务。 如 MYSQL原生的MylSAM引擎就不支持事务，这也是MylSAM 被InnoDB 取代的重要原因之一。</p>
<h4 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h4><p>ACID(Atomicity, Consistency, Isolation, Durability, 即原子性， 一致性， 隔离性，持久性 )。<br>当数据路上有多个事务同时执行的时候， 就可能出现脏读(dirty, read), 不可重复读(non-repeateable read)、<br>幻读(phantom read)的问题， 为了解决这个问题，就有了“隔离级别”的概念。</p>
<p>如果隔离越严实， 效率就会越低。 SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、<br>读提交（read committed）、可重复读（repeatable read）和串行化（serializable）</p>
<ol>
<li>读未提交： 一个事务还没提交时， 它做的变更就能被别的事务看到</li>
<li>读提交： 一个事务提交之后， 它做的变更才会被其他事务看到</li>
<li>可重复读： 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在<br>可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li>
<li>串行化， 对于同一行记录， “写”会加“写锁”， “读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，<br>才能继续执行。</li>
</ol>
<p>隔离区别：<br>假设数据表T中只有一列，其中一行的值为1， 则按时间顺序执行下面两个事务的行为：<br>create table T(c int) engine = InnoDB;<br>insert into T(c) values(1);</p>
<p><img src="/echoblog.github.io/2019/01/01/MYSQL-Study3/affair.png" alt="Affair"></p>
<ol>
<li>若隔离级别是“读未提交”， 则V1 的值就是2. 这时候事务B 虽然还没有提交， 但是结果已经被A看到了。 因此， V2，V3也都是2</li>
<li>若隔离级别是“读提交”，则V1是1， V2 的值是2。 事务B 的更新在提交后才能被A 看到。 所以， V3的值也是2</li>
<li>若隔离级别是“可重复读”， 则V1、V2 是1， V3是2. 之所以V2 还是1， 遵循的就是这个要求： 事务在执行期间看到的数据前后必须是一致的</li>
<li>若隔离级别是“串行化”， 则在事务B 执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看，V1，V2<br>值是1， V3 的值是2。</li>
</ol>
<p>在实现上，数据库里面会创建一个视图， 访问的时候以视图的逻辑结果为准。<br>在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始<br>执行的时候创建的。 需要注意的是， “读未提交”隔离级别下直接返回记录上的最新值，没有视图概念; 而“串行化” 隔离级别下直接返回记录上的最新值，<br>没有视图概念； 而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</p>
<p>不同隔离级别下，数据库行为是有所不同的。 Oracle数据库的默认隔离级别其实是“读提交”， 因此对于一些从Oracle 迁移到MYSQL的应用，<br>为了保证数据库隔离级别的一致， 需要将“MYSQL”的隔离级别设置为“读提交”。</p>
<p>配置方式： 将启动参数 transaction-isolation 的值设置为READ-COMMITTED， 可用show variables 来查看当前的值。<br>show variables like ‘transaction_isolation’;</p>
<p>可重复读出现： 假设在管理一个个人银行账户表。 一个表存了每个月月底的余额， 一个表存了账单明细。 如果需要做数据校对，也就是判断上个月的余额<br>和当前余额的差额，是否与本月账单明细一致。校对者一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响校对结果。此时， 使用“可重复读”<br>隔离级别就很方便。 事务启动时的视图可以认为时静止的，不受其他事务更新的影响。</p>
<h4 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h4><p>“可重复读”<br>在MYSQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上最新值，通过回滚操作，都可以得到前一个状态的值。<br>假设一个值按顺序被改成了2,3,4， 在回滚日志里面就会有类似的记录。</p>
<p><img src="/echoblog.github.io/2019/01/01/MYSQL-Study3/roll-back.png" alt="回滚日志"><br>当前值是4， 但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view. 如图所示， 在视图A,B,C 里面，这一个记录的值分别是1，2，4，同一条记录<br>在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。 对于read-view A, 要得到1， 就必须将当前值依次执行图中所有的回归操作得到。</p>
<p>同时你会发现，即使现在有另外一个事务正在将4改成5，这个事务跟read-view A,B,C 对应的事务是不会冲突的。<br>在不需要的时候才会删除回滚日志， 也就是说，系统会判断，当没有事务再需要用到这些回滚日志的时候就会被删除。<br>什么时候才不需要的呢？就是当系统里面没有比这个回滚日志更早的read-view 的时候。</p>
<p>在实际中，尽量不要使用长事务。<br>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面肯能用到的回滚记录必须保留，<br>这就会导致大量占用存储空间。</p>
<p>在MYSQL 5.5 以及之前的版本，回滚体制是跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。<br>除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库。</p>
<p>####　事务的启动方式<br>MYSQL 的事务启动方式有以下几种：</p>
<ol>
<li>显示启动事务语句， begin或start transaction。 配套的提交语句是commit， 回滚语句是rollback</li>
<li>set autocommit = 0, 这个命令会将这个线程的自动提交关掉。 如只执行一个select 语句， 这个事务就启动了，并且不会自动提交。 这个事务持续寻在直到主动执行commit<br>或者rollback 语句，或者断开连接。</li>
</ol>
<p>有些客户端连接框架会默认连接成功后先执行一个set autocommit = 0 的命令。 这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。</p>
<p>因此，建议使用set autocommit =1,通过显式语句的方式来启动事务。<br>对于一个需求频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次“begin”，减少了语句的交互次数。如果有此顾虑，<br>建议使用commit work and chain 语句。</p>
<p>在autocommit 为1 的情况下，用begin显示启动的事务，如果执行commit 则提交事务。 如果执行commit work and  chain, 则是提交事务并自动启动<br>下一个事务， 这样也省区了再次执行begin语句的开销。 同时带来的好处是从程序开发的角度明确知道每个语句是否处于事务中。</p>
<p>可以在informa_schema 库的innodb_trx这个表中查询长事务，如下面的可以查询持续时间超过60s的事务。<br>select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started)) &gt; 60</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在开发过程中，尽可能的减小事务范围，少用长事务，如果无法避免，保证逻辑日志空间足够用，并且支持动态日志空间增长。监控Innodb_trx表，发现长事务报警。</p>
<p>读未提交：别人改数据的事务尚未提交，我在我的事务中也能读到。<br>读已提交：别人改数据的事务已经提交，我在我的事务中才能读到。<br>可重复读：别人改数据的事务已经提交，我在我的事务中也不去读。<br>串行：我的事务尚未提交，别人就别想改数据。<br>这4种隔离级别，并行性能依次降低，安全性依次提高。</p>
<p>如何避免长事务对业务的影响？<br>应用开发端：</p>
<ol>
<li>确认是否使用了set autocommit = 0. 确认工作可以在测试环境中开展，把MYSQL 的general_log 开起， 然后跑一个业务逻辑。通过general_log的日志<br>来确认。一般框架如果会设置这个值，也会提供参数来控制行为，目标就是把它改成1. </li>
<li>确认是都有不必要的只读事务。有些框架会习惯不管什么语句先用begin/commit 框起来。 有些业务还会把好几个select语句放到了事务中。这种只读<br>事务可以去掉。</li>
<li>业务连接数据库的时候， 根据业务本身的预估，通过SET MAX_EXECUTION_TIME命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长</li>
</ol>
<p>数据库端：</p>
<ol>
<li>监控information_schema.Innodb_trx表，设置长事务阈值，超过就报警或者kill</li>
<li>Percona 的 pt-kill 工具推荐</li>
<li>在业务功能测试阶段要求输出所有的general_log， 分析日志行为提前发现问题</li>
<li>MYSQL 5.6 或者更新版本，innodb_undo_tablespace 设置成2（或者更大值）。 如果真出现大事务导致回滚段过大，这样清理起来会更方便。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://echo557.github.io/echoblog.github.io/2019/01/01/MYSQL-Study3/" data-id="ck1jd1wkz00154kvxan9zw58b" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/echoblog.github.io/tags/QA/">QA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MYSQL-Study2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/echoblog.github.io/2018/12/22/MYSQL-Study2/" class="article-date">
  <time datetime="2018-12-22T03:27:14.000Z" itemprop="datePublished">2018-12-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/echoblog.github.io/categories/MYSQL/">MYSQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/echoblog.github.io/2018/12/22/MYSQL-Study2/">MYSQL-Redo log &amp; Binlog</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="MYSQL的日志模块"><a href="#MYSQL的日志模块" class="headerlink" title="MYSQL的日志模块"></a>MYSQL的日志模块</h3><h4 id="简言"><a href="#简言" class="headerlink" title="简言"></a>简言</h4><p>MYSQL 有两层： Server 层， 主要是完成MYSQL 功能层面得事情；引擎层， 负责存储相关得具体事宜。</p>
<p>创建tabke</p>
<p>create table T(ID int primary key, c int)</p>
<p>update 的语句：<br>update T set c=c+1 where ID=2;</p>
<p>更新流程的所涉及的模块：连接器》分析器》优化器》 执行器》存储引擎。 不过还会涉及到另外两个模块： Redo log（重做日志）和<br>binlog（归档日志）</p>
<h4 id="重要的日志模块-redo-log"><a href="#重要的日志模块-redo-log" class="headerlink" title="重要的日志模块: redo log"></a>重要的日志模块: redo log</h4><p>redo log 是引擎层特有得日志<br>如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的记录，然后再更新，整个过程的IO 成本、<br>查找成本都很高。MYSQL 的解决方案，就是WAL 技术， Write-Ahead Logging， 它的关键点就是先写日志，<br>然后再写磁盘。</p>
<p>具体来说，就是当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到redo log 里面，并更新内存，此时更新就算完成。<br>同时InnoDB 引擎会在适当的时候，将这个操作记录更新到此盘里面，此更新过程往往发生再系统比较空闲的时候。</p>
<p>InnoDB的redo log 是固定大小，比如可以配置一组4个文件，每个文件都是1GB，那么这块“粉板”就能记录4GB 的操作。</p>
<p>write pos 是记录当前记录的位置，一边写一边后移，写到第三号文件末尾后就回到0号文件开头。checkpoint是<br>当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p>
<p>write pos 和 checkpoint之间的是“粉板”上空着的部分， 可以用来记录新的操作。如果write pos 追上 checkpoint，<br>表示粉板满了，这时候不能再执行新的操作，得停下来先擦掉一些记录，把checkpoint 推进一下。</p>
<p>因此，有了redo log, InnoDB就可以保证即使数据库发生异常重启，之前提交得记录都不会丢失，这个能力叫 crash-log</p>
<h4 id="重要日志模块：-binlog（归档日志）"><a href="#重要日志模块：-binlog（归档日志）" class="headerlink" title="重要日志模块： binlog（归档日志）"></a>重要日志模块： binlog（归档日志）</h4><p>Server 层得日志： binlog（归档日志）</p>
<p>最开始MYSQL 里并没有InnoDB引擎。 MYSQL 自带得引擎是MylSAM, 但它没有crash-safe的能力， binlog 日志只能用于归档。<br>而InnoDB 是另一个公司以插件形式引入MYSQL的，所以就使用另一套日志系统 redo log 来实现crash-safe 能力</p>
<p>两个日志的不同点： </p>
<ol>
<li>redo log 是InnoDB 引擎特有的，binlog 是MYSQL 的server层实现的，所有引擎都可以使用。</li>
<li>redo log 是物理日记， 记录的是“在某个数据页上做了什么修改”; binlog 是逻辑日志， 记录的是语句的原始逻辑，<br>比如“给ID=2 这一行的c 字段加1”</li>
<li>redo log 是循环写的，空间固定会用完，binlog 是可以追加写入的。<br>追加写是指binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
</ol>
<p>执行器和InnoDB 引擎在执行这个简单的update 语句时的内部流程。</p>
<ol>
<li>执行器先找到引擎取ID=2 这一行。 ID 时主键， 引擎直接用树搜索到这一行。 如果ID=2<br>这一行所在的数据页本来就在内存中， 就直接返回给执行器； 否则， 需要先从磁盘读取内存，然后再返回。</li>
<li>执行器拿到引擎给的行数据，把值加1， 如变成N+1， 得到新一行数据， 再调用引擎接口写入这行新数据。</li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log 里， 此时redo log 处于prepare状态。<br>然后告知执行器执行完成了，随时可以提交事务。</li>
<li>执行器生成这个操作的binlog, 并把binlog 写入磁盘。</li>
<li>执行器调用引擎的提交事务接口， 引擎把刚写入的redo log 改成提交（commit）状态，更新完成。</li>
</ol>
<p>update 语句的执行流程图，图中浅色框表示是在 InnoDB 内部执行， 深色为执行器中执行。</p>
<p>redo log 的写入有两个步骤： prepare和commit,即两阶段提交。</p>
<h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><p>存在两阶段提交的原因： 为了让两份日志之间的逻辑一致。<br>binlog 会记录所有的逻辑操作， 并且是采用“追加写”的形式。 当需要恢复到指定的某一秒时， 你可以这样做：</p>
<ol>
<li>首先， 找到最近的一次全量备份， 如果你运气好，可能就是昨天晚上的一个备份。从这个备份恢复到临时库。</li>
<li>然后，从备份时间的点开始，将备份的binlog 依次取出， 重放到中午误删表之前的那个时刻。</li>
</ol>
<p>这样临时库就和误删之前的线上库一样了，然后把表数据从临时库取出，按需要恢复到线上库。</p>
<p>为何日志需要“两阶段提交”？<br>由于redo log 和binlog 时两个独立的逻辑， 如果不使用两阶段提交，要么就是先写完redo log 再写<br>binlog， 抑或反过来。可能就会存在以下问题：<br>假设当前ID=2 的行， 字段C 的值时0,再假设执行update语句过程中在写完第一个日志之后， 第二个<br>日志还没有写完期间发生crash,会出现什么？</p>
<ol>
<li>先写redo log 后写binlog。 假设 redo log 写完， binlog 还没有写完时， mysql 进程异常重启。<br>由于前面所说，redo log 写完之后，系统即使奔溃，仍然能把数据恢复回来， 所以恢复后这一行c的值是1.<br>但由于binlog没写完就crash, 这时候binlog里面没有记录这个语句。因此，备份日志的时候，<br>存起来的binlog 里面就没有这条语句。如果用binlog 来恢复临时库的话，由于这个语句的binlog 丢失，<br>这个临时库就会少了这一次更新， 恢复处理的这一行c的值就是0， 与原库的值不同。</li>
<li>先写binlog 后写redo log. 如果在binlog 写完之后crash， 由于redo log还没有写， 崩溃恢复后这个事务无效，<br>所以这一行c的值是0. 但是binlog来恢复的时候就多了一个事务出来， 恢复出来的这一行的值就是1，与原库的值不同。</li>
</ol>
<p>不仅误操作后需要用这个过程来恢复数据，需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，<br>现在最常见的做法也是用全量备份加上应用binlog 来实现， 这个“不一致”就会导致你的线上出现主从数据库不一致的情况。</p>
<p>简单来说， redo log和binlog 都可以用于表示事务的提交状态， 而两阶段提交就是让这两个状态保持逻辑上的一致。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>主要介绍 物理日志 redo log 和 逻辑日志 binlog（归档日志）</p>
<p>redo log 用于保证 crash-safe 能力。 innodb_flush_log_at_trx_commit 这个参数设置成1的时候，<br>表示每次事务的redo log 都直接持久化到磁盘。 此参数设置为1， 就可以保证MYSQL 异常重启之后数据不会丢失。</p>
<p>sync_binlog 参数为1 的时候， 表示每次事务的binlog 都持久化到磁盘。也可以保证MYSQL 异常重启后binlog不会丢失。</p>
<p>两阶段提交时跨系统维持数据逻辑一致性常用的方案， 即使你不做数据库内核开发，日常开发也会使用。</p>
<p>redo log 是记录这个页“做了什么改动”。<br>binlog 有两种模式， statement格式的话是记sql语句， row 格式会记录行的内容，记两条。更新前和更新后都有。</p>
<p>1 prepare阶段 2 写binlog 3 commit<br>当在2之前崩溃时<br>重启恢复：后发现没有commit，回滚。备份恢复：没有binlog 。<br>一致<br>当在3之前崩溃<br>重启恢复：虽没有commit，但满足prepare和binlog完整，所以重启后会自动commit。备份：有binlog. 一致</p>
<p>1.首先客户端通过tcp/ip发送一条sql语句到server层的SQL interface<br>2.SQL interface接到该请求后，先对该条语句进行解析，验证权限是否匹配<br>3.验证通过以后，分析器会对该语句分析,是否语法有错误等<br>4.接下来是优化器器生成相应的执行计划，选择最优的执行计划<br>5.之后会是执行器根据执行计划执行这条语句。在这一步会去open table,如果该table上有MDL，则等待。<br>如果没有，则加在该表上加短暂的MDL(S)<br>(如果opend_table太大,表明open_table_cache太小。需要不停的去打开frm文件)<br>6.进入到引擎层，首先会去innodb_buffer_pool里的data dictionary(元数据信息)得到表信息<br>7.通过元数据信息,去lock info里查出是否会有相关的锁信息，并把这条update语句需要的<br>锁信息写入到lock info里(锁这里还有待补充)<br>8.然后涉及到的老数据通过快照的方式存储到innodb_buffer_pool里的undo page里,并且记录undo log修改的redo<br>(如果data page里有就直接载入到undo page里，如果没有，则需要去磁盘里取出相应page的数据，载入到undo page里)<br>9.在innodb_buffer_pool的data page做update操作。并把操作的物理数据页修改记录到redo log buffer里<br>由于update这个事务会涉及到多个页面的修改，所以redo log buffer里会记录多条页面的修改信息。<br>因为group commit的原因，这次事务所产生的redo log buffer可能会跟随其它事务一同flush并且sync到磁盘上<br>10.同时修改的信息，会按照event的格式,记录到binlog_cache中。(这里注意binlog_cache_size是transaction级别的,不是session级别的参数,<br>一旦commit之后，dump线程会从binlog_cache里把event主动发送给slave的I/O线程)<br>11.之后把这条sql,需要在二级索引上做的修改，写入到change buffer page，等到下次有其他sql需要读取该二级索引时，再去与二级索引做merge<br>(随机I/O变为顺序I/O,但是由于现在的磁盘都是SSD,所以对于寻址来说,随机I/O和顺序I/O差距不大)<br>12.此时update语句已经完成，需要commit或者rollback。这里讨论commit的情况，并且双1<br>13.commit操作，由于存储引擎层与server层之间采用的是内部XA(保证两个事务的一致性,这里主要保证redo log和binlog的原子性),<br>所以提交分为prepare阶段与commit阶段<br>14.prepare阶段,将事务的xid写入，将binlog_cache里的进行flush以及sync操作(大事务的话这步非常耗时)<br>15.commit阶段，由于之前该事务产生的redo log已经sync到磁盘了。所以这步只是在redo log里标记commit<br>16.当binlog和redo log都已经落盘以后，如果触发了刷新脏页的操作，先把该脏页复制到doublewrite buffer里，把doublewrite buffer里的刷新到共享表空间，然后才是通过page cleaner线程把脏页写入到磁盘中<br>老师，你看我的步骤中有什么问题嘛？我感觉第6步那里有点问题,因为第5步已经去open table了，第6步还有没有必要去buffer里查找元数据呢?这元数据是表示的系统的元数据嘛,还是所有表的？谢谢老师指正</p>
<p>其实在实现上5是调用了6的过程了的，所以是一回事。MySQL server 层和InnoDB层都保存了表结构，所以有书上描述时会拆开说。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://echo557.github.io/echoblog.github.io/2018/12/22/MYSQL-Study2/" data-id="ck1jd1wkv00114kvxu9fe3xjo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/echoblog.github.io/tags/QA/">QA</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/echoblog.github.io/page/10/">&laquo; Prev</a><a class="page-number" href="/echoblog.github.io/">1</a><span class="space">&hellip;</span><a class="page-number" href="/echoblog.github.io/page/9/">9</a><a class="page-number" href="/echoblog.github.io/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/echoblog.github.io/page/12/">12</a><a class="page-number" href="/echoblog.github.io/page/13/">13</a><a class="extend next" rel="next" href="/echoblog.github.io/page/12/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/AutoTesting/">AutoTesting</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/English/">English</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/HTTP/">HTTP</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/Jmeter/">Jmeter</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/Lanuage/">Lanuage</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/Learning/">Learning</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/MYSQL/">MYSQL</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/Operation-System/">Operation System</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/Performance/">Performance</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/ProjectManagement/">ProjectManagement</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/SQA/">SQA</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/Strategy/">Strategy</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/Tools/">Tools</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/Trouble-shooting/">Trouble-shooting</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/Automation/">Automation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/CI/">CI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/English/">English</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/Integration/">Integration</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/Interface/">Interface</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/Machine-Leaning/">Machine Leaning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/PMP/">PMP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/Performance/">Performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/Protocol/">Protocol</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/QA/">QA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/SQA/">SQA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/Scripts/">Scripts</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/TestingMethod/">TestingMethod</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/Tools/">Tools</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/Trouble-Shooting/">Trouble Shooting</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/TroubleShooting/">TroubleShooting</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/View/">View</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/js/">js</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/echoblog.github.io/tags/Automation/" style="font-size: 10px;">Automation</a> <a href="/echoblog.github.io/tags/CI/" style="font-size: 12px;">CI</a> <a href="/echoblog.github.io/tags/English/" style="font-size: 10px;">English</a> <a href="/echoblog.github.io/tags/Integration/" style="font-size: 10px;">Integration</a> <a href="/echoblog.github.io/tags/Interface/" style="font-size: 10px;">Interface</a> <a href="/echoblog.github.io/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/echoblog.github.io/tags/Machine-Leaning/" style="font-size: 10px;">Machine Leaning</a> <a href="/echoblog.github.io/tags/PMP/" style="font-size: 10px;">PMP</a> <a href="/echoblog.github.io/tags/Performance/" style="font-size: 16px;">Performance</a> <a href="/echoblog.github.io/tags/Protocol/" style="font-size: 14px;">Protocol</a> <a href="/echoblog.github.io/tags/QA/" style="font-size: 20px;">QA</a> <a href="/echoblog.github.io/tags/SQA/" style="font-size: 12px;">SQA</a> <a href="/echoblog.github.io/tags/Scripts/" style="font-size: 18px;">Scripts</a> <a href="/echoblog.github.io/tags/TestingMethod/" style="font-size: 10px;">TestingMethod</a> <a href="/echoblog.github.io/tags/Tools/" style="font-size: 10px;">Tools</a> <a href="/echoblog.github.io/tags/Trouble-Shooting/" style="font-size: 10px;">Trouble Shooting</a> <a href="/echoblog.github.io/tags/TroubleShooting/" style="font-size: 10px;">TroubleShooting</a> <a href="/echoblog.github.io/tags/View/" style="font-size: 10px;">View</a> <a href="/echoblog.github.io/tags/js/" style="font-size: 10px;">js</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/echoblog.github.io/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/echoblog.github.io/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/echoblog.github.io/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/echoblog.github.io/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/echoblog.github.io/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/echoblog.github.io/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/echoblog.github.io/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/echoblog.github.io/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/echoblog.github.io/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/echoblog.github.io/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/echoblog.github.io/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/echoblog.github.io/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/echoblog.github.io/2019/09/25/git-week1/">git_week1</a>
          </li>
        
          <li>
            <a href="/echoblog.github.io/2019/08/20/IntegrationStratergy/">IntegrationStrategy</a>
          </li>
        
          <li>
            <a href="/echoblog.github.io/2019/08/09/ProjectLeadership/">ProjectLeadership</a>
          </li>
        
          <li>
            <a href="/echoblog.github.io/2019/07/07/MYSQL-Study9/">MYSQL-Study9</a>
          </li>
        
          <li>
            <a href="/echoblog.github.io/2019/06/03/Javascript1/">Javascript1</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Ying<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/echoblog.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/echoblog.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/echoblog.github.io/fancybox/jquery.fancybox.css">
  <script src="/echoblog.github.io/fancybox/jquery.fancybox.pack.js"></script>


<script src="/echoblog.github.io/js/script.js"></script>



  </div>
</body>
</html>