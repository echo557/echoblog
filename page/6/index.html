<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Ying&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Ying&#39;s Blog">
<meta property="og:url" content="https://echo557.github.io/echoblog.github.io/page/6/index.html">
<meta property="og:site_name" content="Ying&#39;s Blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ying&#39;s Blog">
  
    <link rel="alternate" href="/echoblog.github.io/atom.xml" title="Ying&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/echoblog.github.io/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/echoblog.github.io/" id="logo">Ying&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/echoblog.github.io/">Home</a>
        
          <a class="main-nav-link" href="/echoblog.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/echoblog.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://echo557.github.io/echoblog.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-MYSQL-Study6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/echoblog.github.io/2019/01/26/MYSQL-Study6/" class="article-date">
  <time datetime="2019-01-26T12:28:27.000Z" itemprop="datePublished">2019-01-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/echoblog.github.io/categories/MYSQL/">MYSQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/echoblog.github.io/2019/01/26/MYSQL-Study6/">全局锁和表锁</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/echoblog.github.io/2019/01/26/MYSQL-Study6/图一.png" alt="图一"><br><img src="/echoblog.github.io/2019/01/26/MYSQL-Study6/MDL.png" alt="MDL"><br><img src="/echoblog.github.io/2019/01/26/MYSQL-Study6/全局锁和表锁.png" alt="全局锁和表锁"></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h4 id="多用户共享资源，-并出现并发的时候，数据库需要合理地控制资源地访问规则。-而锁就是用来实现这些访问规则地重要数据结构"><a href="#多用户共享资源，-并出现并发的时候，数据库需要合理地控制资源地访问规则。-而锁就是用来实现这些访问规则地重要数据结构" class="headerlink" title="多用户共享资源， 并出现并发的时候，数据库需要合理地控制资源地访问规则。 而锁就是用来实现这些访问规则地重要数据结构"></a>多用户共享资源， 并出现并发的时候，数据库需要合理地控制资源地访问规则。 而锁就是用来实现这些访问规则地重要数据结构</h4><h4 id="三种锁：-全局锁，-表级锁-和行锁"><a href="#三种锁：-全局锁，-表级锁-和行锁" class="headerlink" title="三种锁： 全局锁， 表级锁 和行锁"></a>三种锁： 全局锁， 表级锁 和行锁</h4><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><ul>
<li>全局锁就是对整个数据库实例加锁。 </li>
<li>MySQL提供了一个加全局读锁地方法， 命令： Flush tables with read lock(FTWRL). 如果需要让整个库处于只读状态，可以使用此命令。然后所有语句会被阻塞： 数据库更新（增删改）， 数据定义语句（建表、修改表结构）和更新类事务地语句提交</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>全库逻辑备份。 即把整库每个表都select 出来存成文本。</li>
</ul>
<h3 id="潜在风险"><a href="#潜在风险" class="headerlink" title="潜在风险"></a>潜在风险</h3><ul>
<li>如果主库上备份， 那么备份期间都不能执行更新，业务基本上就得停止</li>
<li>如果从库上备份，那么备份期间从库不能执行主库同步过来地binlog，会导致主从延迟</li>
</ul>
<h3 id="备份加锁目的"><a href="#备份加锁目的" class="headerlink" title="备份加锁目的"></a>备份加锁目的</h3><ul>
<li><p>例子</p>
<ul>
<li>如果维护购买系统， 所要关注的是用户账户余额表和用户课程表</li>
<li>发起逻辑备份。 在备份期间，有一个用户发生购买， 业务逻辑里就要扣除他的余额， 并往已购买中加入购买的东西</li>
<li>如果按照时间顺序备份，先备份账户余额表（u_account）， 然后用户购买，在备份用户课程表（u_course），会如图一所示：</li>
<li>结果用户得到的状态是“账户余额没扣，但是用户课程表里面已经多了一门课”； 如果反过来， 先备份用户课程再备份账户余额表，就会出现用户花了钱，但是课程没有买到</li>
</ul>
</li>
<li><p>目的</p>
<ul>
<li>为了让备份系统备份得到的库再同一个逻辑时间点，页视图也会一致</li>
<li>得到一致视图的方法： 在可重复读隔离级别下开启一个事务</li>
</ul>
</li>
</ul>
<h3 id="逻辑备份工具"><a href="#逻辑备份工具" class="headerlink" title="逻辑备份工具"></a>逻辑备份工具</h3><ul>
<li>官方： mysqldump</li>
<li>当mysqldump 使用参数-single-transaction 的时候，导数据之前就会启动一个事务， 来确保拿到一致性视图。 而由于MVCC 的支持， 这个过程中数据是可以正常更新的</li>
</ul>
<h3 id="为什么需要FTWRL"><a href="#为什么需要FTWRL" class="headerlink" title="为什么需要FTWRL"></a>为什么需要FTWRL</h3><ul>
<li>一致性读是好，但前提是引擎要支持这个隔离级别</li>
<li>如： 对于MylSAM 这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性，此时就需要FTWRL</li>
<li>因此，single-transaction 方法只适用于所有的表使用事务引擎的库。 如果有的表不支持事务的引擎， 那么备份就只能通过FTWRL方法。 这就是DBA 要求业务开发人员使用InnoDB替代MylSAM 的原因之一</li>
</ul>
<h3 id="既然全库只读，为什么不适用-set-global-readonly-true-的方式"><a href="#既然全库只读，为什么不适用-set-global-readonly-true-的方式" class="headerlink" title="既然全库只读，为什么不适用 set global readonly= true 的方式"></a>既然全库只读，为什么不适用 set global readonly= true 的方式</h3><ul>
<li><ol>
<li>在有些系统中， readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。 因此，修改global变量的方式影响面更大</li>
</ol>
</li>
<li><ol start="2">
<li>在异常处理机制上有差异。 如果执行FTWRL 命令后由于客户端发生异常断开，那么MySQL 会自动释放这个全局锁， 整个库回到可以正常更新的状态。 而将整个库设置为readonly 之后，如果客户端发生异常，则数据库会一致保持readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高 </li>
</ol>
</li>
</ul>
<h3 id="业务更新不只是增删改数据（DML，还有可能是加字段等修改表结构的操作（DDL）。-不论哪种方法，一个库被全局锁上以后，要对里面任何一个表做加字段操作，都会被锁住。"><a href="#业务更新不只是增删改数据（DML，还有可能是加字段等修改表结构的操作（DDL）。-不论哪种方法，一个库被全局锁上以后，要对里面任何一个表做加字段操作，都会被锁住。" class="headerlink" title="业务更新不只是增删改数据（DML，还有可能是加字段等修改表结构的操作（DDL）。 不论哪种方法，一个库被全局锁上以后，要对里面任何一个表做加字段操作，都会被锁住。"></a>业务更新不只是增删改数据（DML，还有可能是加字段等修改表结构的操作（DDL）。 不论哪种方法，一个库被全局锁上以后，要对里面任何一个表做加字段操作，都会被锁住。</h3><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>表锁</li>
<li>元数据锁（meta data lock, MDL）</li>
</ul>
<h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><ul>
<li>语法：lock tables.. read/write</li>
<li>和FTWRL 类似， 可以用unlock tables z主动释放锁， 也可以在客户端断开的时候自动释放。需要注意的是， lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</li>
<li>举例： 如果在某个线程A中执行lock tables t1 read, t2 write; 则其他线程写t1 ， 读写t2 的语句都会被阻塞。 同时， 线程A在执行unlock tables 之前， 也只能执行读t1、读写t2 的操作。连写t1 都不允许，自然也不能访问其他表</li>
<li>还未出现更细粒度的锁的时候，表锁是最常用的处理并发方式。而对于InnoDB 这种支持行锁的引擎， 一般不是lock tables 命令来控制并发。</li>
</ul>
<h3 id="元数据锁（MDL）"><a href="#元数据锁（MDL）" class="headerlink" title="元数据锁（MDL）"></a>元数据锁（MDL）</h3><ul>
<li>不需要显式使用，在访问一个表的时候会被自动加上。</li>
<li>作用： 保证读写的正确性。 如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做了变更，删了一行，那么查询线程拿到的结果跟表结构对不上， 肯定是不行的</li>
<li><p>MySQL 5.5 版本引入MDL， 当对一个表做增删改查操作的时候，加MDL 读锁； 当要对表做结构变更操作的时候，加MDL 写锁。</p>
<ul>
<li>读锁之间不互斥， 因此可以有多个线程同时对一张表增删改查</li>
<li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。 因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才开始执行</li>
</ul>
</li>
<li><p>例子</p>
<ul>
<li>MDL 锁是系统默认会加的，但不能忽略例子中的机制</li>
<li>给一个表加字段，或者修改字段，或者加索引， 需要扫描全表的数据。 对于大表，可能会对线上服务造成影响。 但是实际上，即使小表，操作不慎也会出问题</li>
<li><p>假设t 是一个小表（环境是MySQL5.6）， 图MDL</p>
<ul>
<li>可以看到session A 先启动， 这时候会对表t加一个MDL读锁</li>
<li>由于session B需要的也是MDL 读锁，因此可以正常运运行</li>
<li>session C 会被blocked， 因为session A 的MDL 读锁还没有释放， 而session C 需要MDL 写锁， 因此只能被阻塞</li>
<li>如果只有session C 自己被阻塞还没什么关系，但是之后所有要在表t 上新申请MDL 读锁的请求也会被session C 阻塞。因为， 所有对表的增删改查操作都需要先申请MDL 读锁，就都被锁住， 等于这个表现在完全不可读写了</li>
<li>如果某个表上的查询语句频繁， 而且客户端有重试机制， 超时后会再起一个新session 再请求，这个库的线程很快会爆满</li>
</ul>
</li>
</ul>
</li>
<li><p>事务中的MDL 锁， 在语句执行开始时的申请， 但是语句结束后并不会马上释放，会等到整个事务提交后再释放</p>
</li>
<li><p>如何安全地给小表加字段</p>
<ul>
<li>首先要解决长事务， 事务不提交，就会一直占着MDL 锁。 在MySQL的 information_schema库的innodb_trx 表中， 可以查询到当前执行中的事务。</li>
<li>若要做DDL变更的表刚好有长事务在执行， 要考虑先暂停DDL， 或者kill掉这个长事务。</li>
<li>但考虑另外的场景，需要变更的表是一个热点表， 虽然数据量不大， 但请求很频繁。 且不得不加字段， 如何执行。</li>
<li>kill 未必管用，比较理想的机制： 在alter table 语句里面设定等待时间，如果在指定时间内能够拿到MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。然后开发人员或者DBA 再重试执行命令重复此过程。</li>
<li><p>MariaDB 已经合并AliSQL 这个功能， 所以这两个开源分支目前都支持DDL NOWAIT/WAIT n这个语法</p>
<ul>
<li>alter table tbl_name NOWAIT add column ….</li>
<li>Alter table tbl_name WAIT N add column</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="全局锁-1"><a href="#全局锁-1" class="headerlink" title="全局锁"></a>全局锁</h3><ul>
<li>用途： 逻辑备份中</li>
<li>如库全是InnoDB, 可选择 -single-transaction 参数</li>
</ul>
<h3 id="表锁-1"><a href="#表锁-1" class="headerlink" title="表锁"></a>表锁</h3><ul>
<li>用途： 数据库引擎不支持行锁的时候才被用到</li>
<li><p>如果程序里有lock tables 这样的语句， 如何做？</p>
<ul>
<li>要么是系统还是MylSAM 这类不支持事务的引擎， 需要升级换引擎</li>
<li>引擎升级，代码没升级，把lock tables 和unlock tables 改成begin和commit</li>
</ul>
</li>
<li><p>MDL 直到事务提交才释放，表变更需要注意，</p>
<ul>
<li>设置超时等待时间，然后循环提交</li>
</ul>
</li>
</ul>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>备份一般都会再备份库上执行，再用-single-transaction 方法做逻辑备份的过程Hon个如果主库的一个小表做了DDL， 比如给一个表上加了一列。这时候备库看到的现象是什么？</li>
</ul>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul>
<li><p>假设DDL是针对表t1的， 那么备份过程中几个关键语句异常如下</p>
<ul>
<li>Q1： SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</li>
<li>Q2： start transaction with consistent snapshot;</li>
<li>/<em> other tables </em>/ Q3: SAVEPOINT sp;</li>
<li>/<em>时刻1</em>/ Q4： show create table ‘t1’;</li>
<li>/<em>时刻2</em>/ Q5： select * from ‘t1’;</li>
<li>/<em>时刻3</em>/ Q6：rollback to savepoint sp;</li>
<li>/<em>时刻4</em>/ /<em>other tables</em>/</li>
</ul>
</li>
<li><p>在备份开始时，为了确保RR（可重复读）隔离级别，再设置一次RR 隔离级别（Q1）</p>
</li>
<li>启动事务， 使用with consistent snapshot 确保这个语句执行完就可以得到一个一致性视图（Q2）</li>
<li>设置一个保存点， 很重要（Q3）</li>
<li>show create 为了拿到表结构(Q4)， 然后正式导数据（Q5）， 回滚到savepoint sp， 作用是释放t1的MDL 锁（Q6）</li>
<li>DDL 从主库传过来的时间按照效果不同，打了四个时刻。 题目设定为小表， 假定到达后，如果开始执行，则很快能够执行完成</li>
</ul>
<h3 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h3><ul>
<li>如果再Q4 语句执行之前到达， 现象： 没有影响， 备份拿到的是DDL 后的表结构</li>
<li>如果再“时刻2到达”， 则表结构被改过， Q5执行的时候，报Table definition has changed, please retry transaction, 现象： mysqldump 终止</li>
<li>如果再“时刻2”和“时刻3”之间到达，mysqldump 占着t1 的MDL 读锁， binlog 被阻塞，现象： 主从延迟， 直到Q6执行完成</li>
<li>从“时刻4”开始，mysqldump 释放了MDL 读锁， 现象： 没有影响， 备份拿到的是DDL 前的表结构</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://echo557.github.io/echoblog.github.io/2019/01/26/MYSQL-Study6/" data-id="cjuqu78yw000nkgvxe7ytqntl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/echoblog.github.io/tags/QA/">QA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MYSQL-Study5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/echoblog.github.io/2019/01/26/MYSQL-Study5/" class="article-date">
  <time datetime="2019-01-26T01:50:15.000Z" itemprop="datePublished">2019-01-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/echoblog.github.io/categories/MYSQL/">MYSQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/echoblog.github.io/2019/01/26/MYSQL-Study5/">索引下</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/echoblog.github.io/2019/01/26/MYSQL-Study5/索引示意图.png" alt="(name,age)索引示意图"><br><img src="/echoblog.github.io/2019/01/26/MYSQL-Study5/InnoDB索引结构.png" alt="InnoDB索引示意图"><br><img src="/echoblog.github.io/2019/01/26/MYSQL-Study5/图三.png" alt="图三"><br><img src="/echoblog.github.io/2019/01/26/MYSQL-Study5/图四.png" alt="图四"><br><img src="/echoblog.github.io/2019/01/26/MYSQL-Study5/索引（下）.png" alt="索引（下）"></p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h4 id="如果执行select-from-T-where-k-between-3-and-5-需要执行几次树的搜索操作，-会扫描多少行？"><a href="#如果执行select-from-T-where-k-between-3-and-5-需要执行几次树的搜索操作，-会扫描多少行？" class="headerlink" title="如果执行select * from T where k between 3 and 5, 需要执行几次树的搜索操作， 会扫描多少行？"></a>如果执行select * from T where k between 3 and 5, 需要执行几次树的搜索操作， 会扫描多少行？</h4><h4 id="初始化语句：-create-table-T-ID-int-primary-key-k-int-not-null-default-0-s-varchar-16-not-null-default-‘’-indec-k-k-engine-InnoDB"><a href="#初始化语句：-create-table-T-ID-int-primary-key-k-int-not-null-default-0-s-varchar-16-not-null-default-‘’-indec-k-k-engine-InnoDB" class="headerlink" title="初始化语句： create table T(ID int primary key, k int not null default 0, s varchar(16) not null default ‘’, indec k(k)) engine = InnoDB;"></a>初始化语句： create table T(ID int primary key, k int not null default 0, s varchar(16) not null default ‘’, indec k(k)) engine = InnoDB;</h4><h4 id="insert-into-T-values-100-1-‘aa’-200-2-’bb’-300-3-’cc’-500-5-’ee’-600-6-’ff’-700-7-’gg’"><a href="#insert-into-T-values-100-1-‘aa’-200-2-’bb’-300-3-’cc’-500-5-’ee’-600-6-’ff’-700-7-’gg’" class="headerlink" title="insert into T values(100,1, ‘aa’),(200,2,’bb’),(300,3,’cc’),(500,5,’ee’),(600,6,’ff’),(700,7,’gg’);"></a>insert into T values(100,1, ‘aa’),(200,2,’bb’),(300,3,’cc’),(500,5,’ee’),(600,6,’ff’),(700,7,’gg’);</h4><h3 id="SQL执行流程"><a href="#SQL执行流程" class="headerlink" title="SQL执行流程"></a>SQL执行流程</h3><ul>
<li>在k索引树上找到k=3的记录，取得ID=300</li>
<li>再到ID索引树查到ID=300对应的R3</li>
<li>在k索引树取下一个值k=5， 取得ID=500</li>
<li>再回到ID 索引树查到ID=500对应的R4</li>
<li>在k索引树取下一个值k=6， 不满足条件，循环结束</li>
</ul>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><ul>
<li>如果执行语句select ID from T where k between 3 and 5， 这时候只需要查ID的值， 而ID 的值已经在k索引树上，因此可以直接提供查询结果，不需要回表。在这个查询里面，索引k已经“覆盖了”我们的查询需求，称为覆盖索引</li>
<li>需要注意的是， 在引擎内部使用覆盖索引在索引k上其实读了3个记录，R3~R5(对应的索引k上的记录项)，但是对于mysql 的server 层来说，它就是找引擎拿到两条记录，因此mysql 认为扫描行数是2</li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>减少树的搜索次数， 显著提升查询性能， 所以使用覆盖索引是一个常用的性能优化手段</li>
</ul>
<h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><ul>
<li>在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？</li>
<li>Create table ‘tuser’(‘id’ int(11) not null, ‘id_card’ varchar(32) default null, ‘name’ varchar(32) default null, ‘age’ int(11) default null, ‘ismale’ tinyint(1) default null, primary key (‘id’), key ‘id_card’ (‘id_card’), key ‘name_age’ (‘name’, ‘age’) ) ENGINE = InnoDB</li>
<li>根据身份证号查询市民信息的需求，我们只需要在身份证号字段上建立索引就够，在建立一个（身份证，姓名）的联合索引，岂不是浪费空间？</li>
<li>如果现在有一个高频请求，要根据身份证号查询姓名，这个联合索引就有意义。它可以在高频请求上用到覆盖索引， 不在需要需要回表查正航记录</li>
</ul>
<h2 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h2><h3 id="引子-1"><a href="#引子-1" class="headerlink" title="引子"></a>引子</h3><ul>
<li>B+树这种索引结构，可以利用索引的“最左前缀”， 来定位记录</li>
<li>如（name,age）索引示意图， 可以看到索引项是按照索引定义里面出现的字段顺序排序的。</li>
<li>当逻辑需求是查到所有名字是“张三”时，可以快速定位到ID4， 然后遍历得到所有需要的结果</li>
<li>如果要查询所有名字第一个字是“张”， SQL 语句就是“where name like ‘张%’”。此时，可以查到第一个符合条件的记录是ID3， 然后向后遍历，直到不满足条件为止</li>
</ul>
<h3 id="讨论-1"><a href="#讨论-1" class="headerlink" title="讨论"></a>讨论</h3><ul>
<li>在建立联合索引时， 如何安排索引内的字段顺序</li>
<li>评估标准： 索引的复用能力。 </li>
<li>第一原则， 如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的</li>
<li>那么，如果既有联合查询，又有基于a,b各自的查询呢？查询条件里面只有b语句，时无法使用(a,b)这个联合索引的，这时候不得不维护另外一个索引，即（a,b）, (b)这两个</li>
<li>空间原则： 如上面的市民表， name 字段大于age 字段，则建议创建一个（name, age）的联合索引和一个（age）的单字段索引</li>
</ul>
<h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><h3 id="引子-2"><a href="#引子-2" class="headerlink" title="引子"></a>引子</h3><ul>
<li>如果满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。 如果不符合最左前缀的部分，怎样处理呢？</li>
<li>如上面的连个索引（name, age）为例。需求： 检索表中“名字第一个字是张，而且年龄是10 的所有男孩”。 SQL：select * from tuser where name like ‘张%’ and age=10 and ismale =1;</li>
<li><p>执行步骤</p>
<ul>
<li>满足第一个条件，找到记录ID=3</li>
<li>在MySQL 5.6 之前，只能从ID3 开始一个个回表，到主键索引上找出数据行，再对比字段值</li>
<li>MYSQL 5.6 引入索引下推优化， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</li>
<li>图三和图四是两个过程的流程图，每一个虚线箭头表示回表一次</li>
<li>图3中，（name,age）索引里面去掉了age的值， 这个过程InnoDB 并不去去看age的值， 值是按顺序把“name第一个字是张”的记录一条条取出来回表。因此需要回表4次。</li>
<li>图4跟图3的区别是： InnoDB 在（name,age）索引内部就判断了age 是否为10， 对于不为10的记录，直接判断并跳过。则需要回表2次</li>
</ul>
</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><h3 id="覆盖索引-1"><a href="#覆盖索引-1" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><ul>
<li>select ID from T where k between 3 and 5</li>
</ul>
<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><ul>
<li>select ID from T where name like ‘张%’</li>
</ul>
<h3 id="索引下推-1"><a href="#索引下推-1" class="headerlink" title="索引下推"></a>索引下推</h3><ul>
<li>select * from tuser where name like ‘张%’ and age=10 and ismale =1;</li>
</ul>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><h3 id="实际上主键索引也是可以使用多个字段的"><a href="#实际上主键索引也是可以使用多个字段的" class="headerlink" title="实际上主键索引也是可以使用多个字段的"></a>实际上主键索引也是可以使用多个字段的</h3><h3 id="如表定义：-create-table-‘geek’-‘a’-int-11-not-null-‘b’-int-11-not-null-‘c’-int-11-not-null-‘d’-int-11-not-null-primary-key-‘a’-‘b’-key-‘c’-‘c’-key-‘ca’-‘c’-’a’-key-‘cb’-‘c’-‘b’-ENGINE-InnoDB"><a href="#如表定义：-create-table-‘geek’-‘a’-int-11-not-null-‘b’-int-11-not-null-‘c’-int-11-not-null-‘d’-int-11-not-null-primary-key-‘a’-‘b’-key-‘c’-‘c’-key-‘ca’-‘c’-’a’-key-‘cb’-‘c’-‘b’-ENGINE-InnoDB" class="headerlink" title="如表定义： create table ‘geek’(‘a’ int(11) not null, ‘b’ int(11) not null, ‘c’ int(11) not null, ‘d’ int(11) not null, primary key (‘a’, ‘b’), key ‘c’ (‘c’), key ‘ca’ (‘c’,’a’), key ‘cb’ (‘c’, ‘b’))ENGINE = InnoDB;"></a>如表定义： create table ‘geek’(‘a’ int(11) not null, ‘b’ int(11) not null, ‘c’ int(11) not null, ‘d’ int(11) not null, primary key (‘a’, ‘b’), key ‘c’ (‘c’), key ‘ca’ (‘c’,’a’), key ‘cb’ (‘c’, ‘b’))ENGINE = InnoDB;</h3><h3 id="这个表需要a-b-做连个主键索引，-但为什么还有‘ca’，‘cb’两个索引呢？"><a href="#这个表需要a-b-做连个主键索引，-但为什么还有‘ca’，‘cb’两个索引呢？" class="headerlink" title="这个表需要a,b 做连个主键索引， 但为什么还有‘ca’，‘cb’两个索引呢？"></a>这个表需要a,b 做连个主键索引， 但为什么还有‘ca’，‘cb’两个索引呢？</h3><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><ul>
<li>主键a,b的聚簇索引组织顺序相当于order by a,b,也就是按a排序， 再按b排序，c 无序</li>
<li>索引ca的组织是先按c排序，再按a排序， 同时记录主键（注意，这里不是ab， 而是只有b。 这个跟索引c的数据是一模一样的</li>
<li>索引cb的组织是先按c排序，再按b排序，同时记录主键a</li>
<li>因此 ca 可以去掉， cb需要保留</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://echo557.github.io/echoblog.github.io/2019/01/26/MYSQL-Study5/" data-id="cjuqu78yu000lkgvxgrp9ewr5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/echoblog.github.io/tags/QA/">QA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LinuxCommand" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/echoblog.github.io/2019/01/20/LinuxCommand/" class="article-date">
  <time datetime="2019-01-20T13:50:25.000Z" itemprop="datePublished">2019-01-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/echoblog.github.io/categories/Operation-System/">Operation System</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/echoblog.github.io/2019/01/20/LinuxCommand/">Linux Command</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Basic-Command"><a href="#Basic-Command" class="headerlink" title="Basic Command"></a>Basic Command</h3><p>系统信息<br>arch<br>uname -m<br>cat /proc/cpuinfo<br>data</p>
<p>文件搜索<br>find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录<br>find / -user user1 搜索属于用户 ‘user1’ 的文件和目录<br>find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件<br>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://echo557.github.io/echoblog.github.io/2019/01/20/LinuxCommand/" data-id="cjuqu78xy0006kgvxczlb2amc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/echoblog.github.io/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MYSQL-Study4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/echoblog.github.io/2019/01/07/MYSQL-Study4/" class="article-date">
  <time datetime="2019-01-07T12:46:59.000Z" itemprop="datePublished">2019-01-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/echoblog.github.io/categories/MYSQL/">MYSQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/echoblog.github.io/2019/01/07/MYSQL-Study4/">索引上</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="索引上"><a href="#索引上" class="headerlink" title="索引上"></a>索引上</h3><p>索引是为了提高数据库查询的效率， 就像书的目录一样。</p>
<h4 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h4><p>可以用于提高读写效率的数据结构很多，常见的三种数据结构有： 哈希表、有序数组 和搜索树。<br>区别：</p>
<ol>
<li>哈希表是一种以键值对（key-value）存储数据的结构，我们只需要输入待查找的值key, j就能找到对应的值value。 哈希的思路： 把值放在数组里， 用一个哈希函数<br>把key 换算成一个确定的位置， 然后把value放在数组的这个位置。<br>不可避免地， 多个key值经过hash 函数地转换，会出现同一个值得情况。处理这种情况得一种方法是： 拉出一个链表。<br>如一个需要维护得身份证信息和姓名得表，需要根据身份证号找到对应名字，哈希索引示意图：</li>
</ol>
<p><img src="/echoblog.github.io/2019/01/07/MYSQL-Study4/hash.png" alt="Hash"><br>图中，User2 和User4根据身份证号算出来得值都是N，但是没关系，后面还有个链表。<br>若你要查出ID_card_n2对应得name,step： 将ID_card_n2通过hash function 算出N， 然后顺序遍历，找到user2.</p>
<p>主要注意得是， 图中四个ID_card_n得值并不是递增得，这样得好处是增加新user时速度会很快，只需要往后追加。 缺点是： 因为不是有序，<br>所以哈希索引做区间查询得速度是很慢的。<br>所以，哈希表这种结构适用于只有等值查询的场景。 如Memcached 及其他一些NoSQL 引擎。</p>
<ol start="2">
<li>而有序数组在等值查询和范围查询场景中的性能就都非常优秀。 如下图：<br><img src="/echoblog.github.io/2019/01/07/MYSQL-Study4/order.png" alt="Order"></li>
</ol>
<p>假设身份证号没有重复，此数组就是按照身份证号递增的顺序保存的。这时候要查ID_card_n2 对应的名字， 用二分法就可以很快速得到， 时间复杂度是O(LOG(N)).</p>
<p>同时很显然，这个索引结构支持范围查询。 若要查询身份证号在[ID_card_X, ID_card_Y]区间的User, 可以先用二分法找到ID_card_X(<br>如果不存在ID_card_X， 就找到大于ID_card__X的第一个User)， 然后向右遍历， 直到找到第一个大于ID_card_Y 的身份证号，退出循环。</p>
<p>仅看查询效率，有序数组是最好的数据结构。 但更新需要挪动后面所有记录，成本太高。<br>所以，有序数组索引只适用于静态存储引擎， 那些不再修改的数据。</p>
<ol start="3">
<li>二叉搜索树，同样例子如图：<br><img src="/echoblog.github.io/2019/01/07/MYSQL-Study4/tree.png" alt="Tree"></li>
</ol>
<p>二叉搜索树的特点： 每个节点的左儿子小于父节点， 父节点又小于右儿子。 若要查询ID_card_n2的话， 按照图中搜索顺序就是按照UserA&gt;UserC&gt;UserF&gt;User2此路径<br>得到。 这个时间复杂成都是O（log(N)）。</p>
<p>当然为了维持O（log(N)）的查询复杂度， 就需要平衡二叉树， 为了保证这个，更新时间复杂度也是O（log(N)）。</p>
<p>树可以有二叉， 也可以有多叉。 多叉树就是每个节点有多个儿子，儿子之间大小从左到右递增。二叉树的搜索效率是最高的。但是实际上<br>大多数数据库存储却并不使用二叉树。 原因是： 索引不止存在内存中，还要写到磁盘里。</p>
<p>若一颗100万节点的平衡二叉树，树高20.一次查询可能需要访问20个数据块。在机械硬盘时代，从磁盘随机读一个数据库需要10ms 左右的寻址时间。 对于<br>100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10ms。</p>
<p>为了让一个查询尽量少读磁盘，就必须让查询过程访问尽量少的数据块。所以，应该使用N叉树。这里， N叉树中的N取决于数据块大小。 </p>
<p>以InnoDB 为例， N大概是1200. 树高为4的时候，可以存储1200的3次方个值，为17亿。 考虑到树根的数据块总是在内存中，一个<br>10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3此磁盘。 其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了</p>
<p>N叉树由于读写上的性能优点，以及适配磁盘的访问模式。已经被广泛应用在数据库引擎中。<br>跳表、LSM树等数据结构也被用于引擎设计中。</p>
<p>数据库底层存储核心是基于数据库模型的。<br>在MYSQL 中， 索引是在存储引擎层实现的，所以并没有统一索引标准，即不同才存储引擎的索引工作方式并不一样。</p>
<h3 id="InnoDB索引模型"><a href="#InnoDB索引模型" class="headerlink" title="InnoDB索引模型"></a>InnoDB索引模型</h3><p>在InnoDB中， 表是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。 InnoDB使用了B+树索引模型，<br>所以数据是存储在B+树中的。 每个索引在InnoDB里面对应一颗B+树。<br>若， 我们有一个主键列为ID的值， 表中有字段K， 并且在K 上有索引。<br>建表语句：<br>create table T(<br>id int primary key,<br>k int not null,<br>name varchar(16),<br>index (k))engine = InnoDB;</p>
<p>表中R1-R5的(ID,k)值分别为（100,1）,(200,2),(300,3),(400,4),(500,5)和(600,6)， 两棵树示例如下：<br><img src="/echoblog.github.io/2019/01/07/MYSQL-Study4/InnoDB.png" alt="InnoDB Example"></p>
<p>根据叶子节点的内容，索引类型分为主键索引 和非主键索引。 主键索引的叶子节点存的是整行数据， 在InnoDB里，<br>主键索引也被称为聚簇索引（clustered index）。 非主键索引的叶子节点内容是主键的值。 在InnoDB中，非<br>主键索引也称为二级索引（secondary index）。</p>
<p>基于主键索引和普通索引的查询区别：</p>
<ol>
<li>如果语句是select * from T where ID=500, 即主键查询方式，则只需要搜索ID 这颗B+树。</li>
<li>如果语句是 select * from T where k=5， 即普通索引查询方式，则需要先搜索k索引树， 得到ID 的<br>值为500， 再到ID 索引树搜索一次。 此过程叫回表。</li>
</ol>
<p>因此我们再应用中应尽量使用主键查询。</p>
<h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><p>B+ 树为了索引有序性， 在插入新值得时候需要做必要得维护。<br>以上图为例，如果插入新的行ID 值为700， 则只需要在R5的记录后面插入一个新记录。如果新插入的ID 值为400，<br>就相对麻烦，需要逻辑上挪动后面的数据，空出位置。更糟糕的是，如果R5 所在数据页已经满了，根据B+树的算法，<br>这时候就需要申请一个新的数据页，然后挪动部分数据过去。此过程叫页分裂，这种状况下啊，性能就会受到影响。</p>
<p>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。<br>当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p>
<p>基于上面索引维护过程说明，可以做以下讨论：<br>可能在一些建表规范中见过类似描述， 要求建表语句里一定要有自增主键。那么可以分析以下哪些场景下应该使用自增主键，哪些不该。</p>
<p>自增主键： 自增列上定义的主键，在建表语句中一般定义：NOT NULL PRIMARY KEY AUTO_INCREMENT<br>插入新记录的时候可以不指定ID 值， 系统会获取当前ID最大值加1作为下一条记录的ID 值。<br>即， 自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，<br>都不涉及到挪动其他记录，也不会触及到叶子节点的分裂。</p>
<p>而有业务逻辑的字段做主键则往往不容易保证有序插入，这样写数据成本相对较高。</p>
<p>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证做主键，那么每个二级索引的叶子节点占用约20个字节，如果整型做<br>主键，则只要4个字节，如果长整型(bigint)则是8个字节。</p>
<p>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</p>
<p>所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。</p>
<p>有没有什么场景适合用业务字段直接做主键的呢？ 如：有些业务场景需求是：</p>
<ol>
<li>只有一个索引</li>
<li>该索引必须是唯一索引<br>KV场景</li>
</ol>
<p>需要尽量使用主键查询原则，直接将索引设置为主键，可以避免每次搜索两棵树。</p>
<h4 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h4><p>通过两个alter 语句重建索引k,以及通过两个alter 语句重建主键索引是否合理。</p>
<p>为什么要重建索引？<br>索引可能因为删除，或者页分裂等原因，导致数据页有空洞， 重建索引的过程会创建一个新的索引，把数据按顺序插入，可以让页面利用率最高。</p>
<p>重建索引k的做法是合理的，可以达到省空间的目的。但是，重建主键的过程不合理。 不论是删除主键还是创建主键，都会将整个表重建。<br>所以连着执行两个语句，第一个语句就会白做。所以可以用语句代替： alter table T engine=InnoDB</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://echo557.github.io/echoblog.github.io/2019/01/07/MYSQL-Study4/" data-id="cjuqu78ym000hkgvx4j1p4nff" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/echoblog.github.io/tags/QA/">QA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MYSQL-Study3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/echoblog.github.io/2019/01/01/MYSQL-Study3/" class="article-date">
  <time datetime="2019-01-01T09:42:59.000Z" itemprop="datePublished">2019-01-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/echoblog.github.io/categories/MYSQL/">MYSQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/echoblog.github.io/2019/01/01/MYSQL-Study3/">隔离</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>####　事务隔离<br>事务是保证一组数据库操作，要么全部成功，要么全部失败。　在ＭySQA中，事务支持是在引擎层实现的。MySQL是一个支持多引擎的系统，<br>但并不是所有的引擎都支持事务。 如 MYSQL原生的MylSAM引擎就不支持事务，这也是MylSAM 被InnoDB 取代的重要原因之一。</p>
<h4 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h4><p>ACID(Atomicity, Consistency, Isolation, Durability, 即原子性， 一致性， 隔离性，持久性 )。<br>当数据路上有多个事务同时执行的时候， 就可能出现脏读(dirty, read), 不可重复读(non-repeateable read)、<br>幻读(phantom read)的问题， 为了解决这个问题，就有了“隔离级别”的概念。</p>
<p>如果隔离越严实， 效率就会越低。 SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、<br>读提交（read committed）、可重复读（repeatable read）和串行化（serializable）</p>
<ol>
<li>读未提交： 一个事务还没提交时， 它做的变更就能被别的事务看到</li>
<li>读提交： 一个事务提交之后， 它做的变更才会被其他事务看到</li>
<li>可重复读： 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在<br>可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li>
<li>串行化， 对于同一行记录， “写”会加“写锁”， “读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，<br>才能继续执行。</li>
</ol>
<p>隔离区别：<br>假设数据表T中只有一列，其中一行的值为1， 则按时间顺序执行下面两个事务的行为：<br>create table T(c int) engine = InnoDB;<br>insert into T(c) values(1);</p>
<p><img src="/echoblog.github.io/2019/01/01/MYSQL-Study3/affair.png" alt="Affair"></p>
<ol>
<li>若隔离级别是“读未提交”， 则V1 的值就是2. 这时候事务B 虽然还没有提交， 但是结果已经被A看到了。 因此， V2，V3也都是2</li>
<li>若隔离级别是“读提交”，则V1是1， V2 的值是2。 事务B 的更新在提交后才能被A 看到。 所以， V3的值也是2</li>
<li>若隔离级别是“可重复读”， 则V1、V2 是1， V3是2. 之所以V2 还是1， 遵循的就是这个要求： 事务在执行期间看到的数据前后必须是一致的</li>
<li>若隔离级别是“串行化”， 则在事务B 执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看，V1，V2<br>值是1， V3 的值是2。</li>
</ol>
<p>在实现上，数据库里面会创建一个视图， 访问的时候以视图的逻辑结果为准。<br>在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始<br>执行的时候创建的。 需要注意的是， “读未提交”隔离级别下直接返回记录上的最新值，没有视图概念; 而“串行化” 隔离级别下直接返回记录上的最新值，<br>没有视图概念； 而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</p>
<p>不同隔离级别下，数据库行为是有所不同的。 Oracle数据库的默认隔离级别其实是“读提交”， 因此对于一些从Oracle 迁移到MYSQL的应用，<br>为了保证数据库隔离级别的一致， 需要将“MYSQL”的隔离级别设置为“读提交”。</p>
<p>配置方式： 将启动参数 transaction-isolation 的值设置为READ-COMMITTED， 可用show variables 来查看当前的值。<br>show variables like ‘transaction_isolation’;</p>
<p>可重复读出现： 假设在管理一个个人银行账户表。 一个表存了每个月月底的余额， 一个表存了账单明细。 如果需要做数据校对，也就是判断上个月的余额<br>和当前余额的差额，是否与本月账单明细一致。校对者一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响校对结果。此时， 使用“可重复读”<br>隔离级别就很方便。 事务启动时的视图可以认为时静止的，不受其他事务更新的影响。</p>
<h4 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h4><p>“可重复读”<br>在MYSQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上最新值，通过回滚操作，都可以得到前一个状态的值。<br>假设一个值按顺序被改成了2,3,4， 在回滚日志里面就会有类似的记录。</p>
<p><img src="/echoblog.github.io/2019/01/01/MYSQL-Study3/roll-back.png" alt="回滚日志"><br>当前值是4， 但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view. 如图所示， 在视图A,B,C 里面，这一个记录的值分别是1，2，4，同一条记录<br>在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。 对于read-view A, 要得到1， 就必须将当前值依次执行图中所有的回归操作得到。</p>
<p>同时你会发现，即使现在有另外一个事务正在将4改成5，这个事务跟read-view A,B,C 对应的事务是不会冲突的。<br>在不需要的时候才会删除回滚日志， 也就是说，系统会判断，当没有事务再需要用到这些回滚日志的时候就会被删除。<br>什么时候才不需要的呢？就是当系统里面没有比这个回滚日志更早的read-view 的时候。</p>
<p>在实际中，尽量不要使用长事务。<br>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面肯能用到的回滚记录必须保留，<br>这就会导致大量占用存储空间。</p>
<p>在MYSQL 5.5 以及之前的版本，回滚体制是跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。<br>除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库。</p>
<p>####　事务的启动方式<br>MYSQL 的事务启动方式有以下几种：</p>
<ol>
<li>显示启动事务语句， begin或start transaction。 配套的提交语句是commit， 回滚语句是rollback</li>
<li>set autocommit = 0, 这个命令会将这个线程的自动提交关掉。 如只执行一个select 语句， 这个事务就启动了，并且不会自动提交。 这个事务持续寻在直到主动执行commit<br>或者rollback 语句，或者断开连接。</li>
</ol>
<p>有些客户端连接框架会默认连接成功后先执行一个set autocommit = 0 的命令。 这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。</p>
<p>因此，建议使用set autocommit =1,通过显式语句的方式来启动事务。<br>对于一个需求频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次“begin”，减少了语句的交互次数。如果有此顾虑，<br>建议使用commit work and chain 语句。</p>
<p>在autocommit 为1 的情况下，用begin显示启动的事务，如果执行commit 则提交事务。 如果执行commit work and  chain, 则是提交事务并自动启动<br>下一个事务， 这样也省区了再次执行begin语句的开销。 同时带来的好处是从程序开发的角度明确知道每个语句是否处于事务中。</p>
<p>可以在informa_schema 库的innodb_trx这个表中查询长事务，如下面的可以查询持续时间超过60s的事务。<br>select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started)) &gt; 60</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在开发过程中，尽可能的减小事务范围，少用长事务，如果无法避免，保证逻辑日志空间足够用，并且支持动态日志空间增长。监控Innodb_trx表，发现长事务报警。</p>
<p>读未提交：别人改数据的事务尚未提交，我在我的事务中也能读到。<br>读已提交：别人改数据的事务已经提交，我在我的事务中才能读到。<br>可重复读：别人改数据的事务已经提交，我在我的事务中也不去读。<br>串行：我的事务尚未提交，别人就别想改数据。<br>这4种隔离级别，并行性能依次降低，安全性依次提高。</p>
<p>如何避免长事务对业务的影响？<br>应用开发端：</p>
<ol>
<li>确认是否使用了set autocommit = 0. 确认工作可以在测试环境中开展，把MYSQL 的general_log 开起， 然后跑一个业务逻辑。通过general_log的日志<br>来确认。一般框架如果会设置这个值，也会提供参数来控制行为，目标就是把它改成1. </li>
<li>确认是都有不必要的只读事务。有些框架会习惯不管什么语句先用begin/commit 框起来。 有些业务还会把好几个select语句放到了事务中。这种只读<br>事务可以去掉。</li>
<li>业务连接数据库的时候， 根据业务本身的预估，通过SET MAX_EXECUTION_TIME命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长</li>
</ol>
<p>数据库端：</p>
<ol>
<li>监控information_schema.Innodb_trx表，设置长事务阈值，超过就报警或者kill</li>
<li>Percona 的 pt-kill 工具推荐</li>
<li>在业务功能测试阶段要求输出所有的general_log， 分析日志行为提前发现问题</li>
<li>MYSQL 5.6 或者更新版本，innodb_undo_tablespace 设置成2（或者更大值）。 如果真出现大事务导致回滚段过大，这样清理起来会更方便。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://echo557.github.io/echoblog.github.io/2019/01/01/MYSQL-Study3/" data-id="cjuqu78yi000fkgvx6xeyel74" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/echoblog.github.io/tags/QA/">QA</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/echoblog.github.io/page/5/">&laquo; Prev</a><a class="page-number" href="/echoblog.github.io/">1</a><span class="space">&hellip;</span><a class="page-number" href="/echoblog.github.io/page/4/">4</a><a class="page-number" href="/echoblog.github.io/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/echoblog.github.io/page/7/">7</a><a class="page-number" href="/echoblog.github.io/page/8/">8</a><a class="extend next" rel="next" href="/echoblog.github.io/page/7/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/AutoTesting/">AutoTesting</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/English/">English</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/Jmeter/">Jmeter</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/Learning/">Learning</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/MYSQL/">MYSQL</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/Operation-System/">Operation System</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/Performance/">Performance</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/SQA/">SQA</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/Tools/">Tools</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/Trouble-shooting/">Trouble-shooting</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/Automation/">Automation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/English/">English</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/Machine-Leaning/">Machine Leaning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/Performance/">Performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/QA/">QA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/SQA/">SQA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/Scripts/">Scripts</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/Tools/">Tools</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/Trouble-Shooting/">Trouble Shooting</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/echoblog.github.io/tags/Automation/" style="font-size: 10px;">Automation</a> <a href="/echoblog.github.io/tags/English/" style="font-size: 10px;">English</a> <a href="/echoblog.github.io/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/echoblog.github.io/tags/Machine-Leaning/" style="font-size: 10px;">Machine Leaning</a> <a href="/echoblog.github.io/tags/Performance/" style="font-size: 13.33px;">Performance</a> <a href="/echoblog.github.io/tags/QA/" style="font-size: 20px;">QA</a> <a href="/echoblog.github.io/tags/SQA/" style="font-size: 13.33px;">SQA</a> <a href="/echoblog.github.io/tags/Scripts/" style="font-size: 16.67px;">Scripts</a> <a href="/echoblog.github.io/tags/Tools/" style="font-size: 10px;">Tools</a> <a href="/echoblog.github.io/tags/Trouble-Shooting/" style="font-size: 10px;">Trouble Shooting</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/echoblog.github.io/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/echoblog.github.io/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/echoblog.github.io/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/echoblog.github.io/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/echoblog.github.io/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/echoblog.github.io/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/echoblog.github.io/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/echoblog.github.io/2019/04/21/python8/">Python Multiple Threading</a>
          </li>
        
          <li>
            <a href="/echoblog.github.io/2019/04/21/python7/">Selenium Grid2</a>
          </li>
        
          <li>
            <a href="/echoblog.github.io/2019/04/20/python6/">HTMLTestRunner</a>
          </li>
        
          <li>
            <a href="/echoblog.github.io/2019/04/18/java-framework/">java-framework</a>
          </li>
        
          <li>
            <a href="/echoblog.github.io/2019/04/18/Jmeter2/">Jmeter2</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Ying<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/echoblog.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/echoblog.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/echoblog.github.io/fancybox/jquery.fancybox.css">
  <script src="/echoblog.github.io/fancybox/jquery.fancybox.pack.js"></script>


<script src="/echoblog.github.io/js/script.js"></script>



  </div>
</body>
</html>