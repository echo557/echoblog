<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Ying&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Ying&#39;s Blog">
<meta property="og:url" content="https://echo557.github.io/echoblog.github.io/page/8/index.html">
<meta property="og:site_name" content="Ying&#39;s Blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ying&#39;s Blog">
  
    <link rel="alternate" href="/echoblog.github.io/atom.xml" title="Ying&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/echoblog.github.io/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/echoblog.github.io/" id="logo">Ying&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/echoblog.github.io/">Home</a>
        
          <a class="main-nav-link" href="/echoblog.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/echoblog.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://echo557.github.io/echoblog.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-MYSQL-Study7" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/echoblog.github.io/2019/01/27/MYSQL-Study7/" class="article-date">
  <time datetime="2019-01-27T09:18:25.000Z" itemprop="datePublished">2019-01-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/echoblog.github.io/categories/MYSQL/">MYSQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/echoblog.github.io/2019/01/27/MYSQL-Study7/">行锁</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/echoblog.github.io/2019/01/27/MYSQL-Study7/图一.png" alt="图一"><br><img src="/echoblog.github.io/2019/01/27/MYSQL-Study7/图二.png" alt="图二"><br><img src="/echoblog.github.io/2019/01/27/MYSQL-Study7/行锁.png" alt="行锁"></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h3 id="MySQL-的行锁实在引擎层由各个引擎自己实现的。-但并不是所有的引擎都支持行锁，-如mylSAM-引擎就不支持行锁。不支持行锁意味这并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，-会影响到业务并发度。"><a href="#MySQL-的行锁实在引擎层由各个引擎自己实现的。-但并不是所有的引擎都支持行锁，-如mylSAM-引擎就不支持行锁。不支持行锁意味这并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，-会影响到业务并发度。" class="headerlink" title="MySQL 的行锁实在引擎层由各个引擎自己实现的。 但并不是所有的引擎都支持行锁， 如mylSAM 引擎就不支持行锁。不支持行锁意味这并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行， 会影响到业务并发度。"></a>MySQL 的行锁实在引擎层由各个引擎自己实现的。 但并不是所有的引擎都支持行锁， 如mylSAM 引擎就不支持行锁。不支持行锁意味这并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行， 会影响到业务并发度。</h3><h3 id="InnoDB-支持行锁。-如事务A-更新了一行，事务B-要更新同一行，则必须等事务A擦做完成后才能进行更新。"><a href="#InnoDB-支持行锁。-如事务A-更新了一行，事务B-要更新同一行，则必须等事务A擦做完成后才能进行更新。" class="headerlink" title="InnoDB 支持行锁。 如事务A 更新了一行，事务B 要更新同一行，则必须等事务A擦做完成后才能进行更新。"></a>InnoDB 支持行锁。 如事务A 更新了一行，事务B 要更新同一行，则必须等事务A擦做完成后才能进行更新。</h3><h2 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h2><h3 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h3><ul>
<li>例子操作中， 事务B 的update语句执行时回事怎样呢？ 假设字段id 是表t的主键 图一</li>
<li>问题的结论取决于事务A在执行完两条update 语句后，持有哪些锁，以及在什么时候释放。</li>
<li>验证后， 实际上事务B 的update语句会被阻塞， 直到事务A执行commit之后，事务B才能继续执行。事务A持有的两条记录的锁，都是在commit 之后释放的</li>
</ul>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li><p>两阶段锁协议</p>
<ul>
<li>在InnoDB 事务中，行锁实在需要的时候才加上，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。</li>
</ul>
</li>
<li><p>如果事务中需要锁多个行，要把最可能造成锁冲突，最可能影响并发度的锁尽量往后放</p>
</li>
</ul>
<h3 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h3><ul>
<li>若果要负责实现一个电影票在线交易业务，顾客A要在影院B购买电影票</li>
<li><p>涉及操作</p>
<ul>
<li><ol>
<li>从顾客A账户余额中扣除电影票价</li>
</ol>
</li>
<li><ol start="2">
<li>给影院B的账户余额增加这张电影票价</li>
</ol>
</li>
<li><ol start="3">
<li>记录一条交易日志</li>
</ol>
</li>
</ul>
</li>
<li><p>如果同时有另外一个顾客要在B 影院买票， 那么这两个事务冲突的部分就是语句2.。 因为他们要更新同一个影院账户的余额，需要修改同一行数据。</p>
</li>
<li>根据两阶段锁协议，不论怎样安排语句顺序，所有的操作需要的行锁都在事务提交的时候才释放。 如果把语句2安排在最后， 比如按照3，1，2这样的顺序， 那么影院账户余额这一行的锁时间就最少最大程度地减少了事务之间地锁等待， 提升了并发度</li>
<li>但如果影院做活动，可以低价预售一年内所有地电影票，活动持续一条。可能活动开始地时候MySQL就挂了。 CPU 消耗接近100%，但整个数据库美标执行不到100个事务</li>
</ul>
<h2 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li><p>概念</p>
<ul>
<li>当并发系统中不同线程出现循环资源依赖， 涉及地线程都在等待别地线程释放资源时，就会导致这几个线程都进入无限等待地状态</li>
</ul>
</li>
<li><p>例子（图二）</p>
<ul>
<li>事务A 在等待事务B 释放 id=2 的行锁，而事务B 在等待事务A 释放id=1 的行锁。 事务A和B 互相等待对方释放资源，就进入了死锁状态</li>
<li><p>解决办法</p>
<ul>
<li>直接进入等待，直到超时。 这个超时时间可以通过参数innodb_lock_wait_timeout来设置</li>
<li>发起死锁检测，发现死锁后，主动回滚死锁链条中的，某一个事务，让其他事务得以继续执行。 将参数innodb_deadlock_detect 设置为on,表示开启这个逻辑</li>
</ul>
</li>
<li><p>分析： 在InnoDB 中，innodb_lock_wait_timeout的默认值是50s,使用第一个方法，当出现死锁以后，第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。 但是超时时间又不能设置得很短，因为回出现很多误伤。</p>
</li>
<li>所以我们会使用第二种方案</li>
</ul>
</li>
</ul>
<h3 id="主动死锁检测"><a href="#主动死锁检测" class="headerlink" title="主动死锁检测"></a>主动死锁检测</h3><ul>
<li><p>引子</p>
<ul>
<li>innodb_deadlock_detect的默认值本身就是on. 主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的。但他也有额外负担。</li>
<li>可以想象过程：每当一个事务被锁得时候，就要看看她所依赖得线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁</li>
<li>每个新来的被堵住的过程，都要判断会不会由于自己的加入导致了死锁，这个是一个时间复杂度是O(n)的操作。 假设有100个并发线程要同时更新同一行，那么死锁检测操作就是100万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的CPU资源。</li>
</ul>
</li>
<li><p>如何解决由这种热点行更新导致的性能问题呢？</p>
<ul>
<li><p>问题症结</p>
<ul>
<li>死锁检测要耗费大量的CPU 资源</li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li>如果该业务一定不会出现死锁，可以临时把死锁检测关掉。但这种操作有一定风险，因为业务设计的时候一般不会把死锁当作一个严重错误，毕竟出现死锁，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关掉死锁检测可能会出现大量超时，就会业务有损。</li>
<li><p>控制并发度。 如果并发度能够控制，比如同一行同时最多只有10个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。</p>
<ul>
<li>客户端并发控制。此方法可能不太可行，因为客户端很多。见过一个应用，600个客户端，即使每个客户端控制到只有5个并发线程，汇总到数据库服务端后，峰值并发数也可能达到3000</li>
<li>因此，数据库服务端并发控制。如果有中间件，可以考虑在中间件实现； 或者有人可以修改MySQL源码，也可以放在MySQL里。</li>
<li>原理， 对于相同行的更新，在进入引擎之前排队。在InnoDB内部就不会有大量的死锁检测工作。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="如何从设计上优化这个问题？"><a href="#如何从设计上优化这个问题？" class="headerlink" title="如何从设计上优化这个问题？"></a>如何从设计上优化这个问题？</h3><ul>
<li>可以考虑通过将一行改成逻辑上的多行来减少锁冲突。</li>
<li>以刚刚的影院账户为例，可以考虑放在多条记录上，比如10个记录，影院的账户总额等于这10个记录值得总和。 每次要个影院账户加金额得时候，随机选其中一条记录来加。这样每次冲突概率变成原来得1/10， 可以减少锁等待个数，也就减少了死锁检测得CPU 消耗</li>
<li>这个方案看起来无损，但是需要根据业务逻辑做详细设计。如果账户余额可能会减少，比如退票逻辑，你这时候就需要考虑当一部分行记录变成0得时候，代码要有特殊处理</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="两阶段锁协议"><a href="#两阶段锁协议" class="headerlink" title="两阶段锁协议"></a>两阶段锁协议</h3><ul>
<li>原则： 如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度得锁得申请时机尽量往后放</li>
<li>调整语句顺序比能不能完全避免死锁</li>
</ul>
<h3 id="死锁和死锁检测-1"><a href="#死锁和死锁检测-1" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h3><ul>
<li>方案1： 直接进入等待，直到超时。 这个超时时间可以通过参数innodb_lock_wait_timeout来设置</li>
<li>方案2：发起死锁检测，发现死锁后，主动回滚死锁链条中的，某一个事务，让其他事务得以继续执行。 将参数innodb_deadlock_detect 设置为on,表示开启这个逻辑 </li>
<li>方案3： 控制并发度。 （主要方向）</li>
</ul>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li><p>要删除一个表里面得前10000行数据，三种方法</p>
<ul>
<li>第一种： 直接执行 delete from T limit 10000;</li>
<li>第二种： 在一个链接中循环执行20次 delete from T limit 500;</li>
<li>第三种： 在20个连接中同时执行20次 delete from T limit 500;</li>
</ul>
</li>
<li><p>如何选择，为什么？</p>
<ul>
<li>第二种相对较好</li>
<li>第一种方式（即： 直接执行 delete from T limit 10000）里面， 单个语句占用时间长，锁得时间也比较长，而且大事务还会导致主从延迟</li>
<li>第三种方式， 会认为造成锁冲突</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://echo557.github.io/echoblog.github.io/2019/01/27/MYSQL-Study7/" data-id="cjv2hm8qh000tuwvxweo3h4no" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/echoblog.github.io/tags/QA/">QA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MYSQL-Study6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/echoblog.github.io/2019/01/26/MYSQL-Study6/" class="article-date">
  <time datetime="2019-01-26T12:28:27.000Z" itemprop="datePublished">2019-01-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/echoblog.github.io/categories/MYSQL/">MYSQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/echoblog.github.io/2019/01/26/MYSQL-Study6/">全局锁和表锁</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/echoblog.github.io/2019/01/26/MYSQL-Study6/图一.png" alt="图一"><br><img src="/echoblog.github.io/2019/01/26/MYSQL-Study6/MDL.png" alt="MDL"><br><img src="/echoblog.github.io/2019/01/26/MYSQL-Study6/全局锁和表锁.png" alt="全局锁和表锁"></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h4 id="多用户共享资源，-并出现并发的时候，数据库需要合理地控制资源地访问规则。-而锁就是用来实现这些访问规则地重要数据结构"><a href="#多用户共享资源，-并出现并发的时候，数据库需要合理地控制资源地访问规则。-而锁就是用来实现这些访问规则地重要数据结构" class="headerlink" title="多用户共享资源， 并出现并发的时候，数据库需要合理地控制资源地访问规则。 而锁就是用来实现这些访问规则地重要数据结构"></a>多用户共享资源， 并出现并发的时候，数据库需要合理地控制资源地访问规则。 而锁就是用来实现这些访问规则地重要数据结构</h4><h4 id="三种锁：-全局锁，-表级锁-和行锁"><a href="#三种锁：-全局锁，-表级锁-和行锁" class="headerlink" title="三种锁： 全局锁， 表级锁 和行锁"></a>三种锁： 全局锁， 表级锁 和行锁</h4><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><ul>
<li>全局锁就是对整个数据库实例加锁。 </li>
<li>MySQL提供了一个加全局读锁地方法， 命令： Flush tables with read lock(FTWRL). 如果需要让整个库处于只读状态，可以使用此命令。然后所有语句会被阻塞： 数据库更新（增删改）， 数据定义语句（建表、修改表结构）和更新类事务地语句提交</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>全库逻辑备份。 即把整库每个表都select 出来存成文本。</li>
</ul>
<h3 id="潜在风险"><a href="#潜在风险" class="headerlink" title="潜在风险"></a>潜在风险</h3><ul>
<li>如果主库上备份， 那么备份期间都不能执行更新，业务基本上就得停止</li>
<li>如果从库上备份，那么备份期间从库不能执行主库同步过来地binlog，会导致主从延迟</li>
</ul>
<h3 id="备份加锁目的"><a href="#备份加锁目的" class="headerlink" title="备份加锁目的"></a>备份加锁目的</h3><ul>
<li><p>例子</p>
<ul>
<li>如果维护购买系统， 所要关注的是用户账户余额表和用户课程表</li>
<li>发起逻辑备份。 在备份期间，有一个用户发生购买， 业务逻辑里就要扣除他的余额， 并往已购买中加入购买的东西</li>
<li>如果按照时间顺序备份，先备份账户余额表（u_account）， 然后用户购买，在备份用户课程表（u_course），会如图一所示：</li>
<li>结果用户得到的状态是“账户余额没扣，但是用户课程表里面已经多了一门课”； 如果反过来， 先备份用户课程再备份账户余额表，就会出现用户花了钱，但是课程没有买到</li>
</ul>
</li>
<li><p>目的</p>
<ul>
<li>为了让备份系统备份得到的库再同一个逻辑时间点，页视图也会一致</li>
<li>得到一致视图的方法： 在可重复读隔离级别下开启一个事务</li>
</ul>
</li>
</ul>
<h3 id="逻辑备份工具"><a href="#逻辑备份工具" class="headerlink" title="逻辑备份工具"></a>逻辑备份工具</h3><ul>
<li>官方： mysqldump</li>
<li>当mysqldump 使用参数-single-transaction 的时候，导数据之前就会启动一个事务， 来确保拿到一致性视图。 而由于MVCC 的支持， 这个过程中数据是可以正常更新的</li>
</ul>
<h3 id="为什么需要FTWRL"><a href="#为什么需要FTWRL" class="headerlink" title="为什么需要FTWRL"></a>为什么需要FTWRL</h3><ul>
<li>一致性读是好，但前提是引擎要支持这个隔离级别</li>
<li>如： 对于MylSAM 这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性，此时就需要FTWRL</li>
<li>因此，single-transaction 方法只适用于所有的表使用事务引擎的库。 如果有的表不支持事务的引擎， 那么备份就只能通过FTWRL方法。 这就是DBA 要求业务开发人员使用InnoDB替代MylSAM 的原因之一</li>
</ul>
<h3 id="既然全库只读，为什么不适用-set-global-readonly-true-的方式"><a href="#既然全库只读，为什么不适用-set-global-readonly-true-的方式" class="headerlink" title="既然全库只读，为什么不适用 set global readonly= true 的方式"></a>既然全库只读，为什么不适用 set global readonly= true 的方式</h3><ul>
<li><ol>
<li>在有些系统中， readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。 因此，修改global变量的方式影响面更大</li>
</ol>
</li>
<li><ol start="2">
<li>在异常处理机制上有差异。 如果执行FTWRL 命令后由于客户端发生异常断开，那么MySQL 会自动释放这个全局锁， 整个库回到可以正常更新的状态。 而将整个库设置为readonly 之后，如果客户端发生异常，则数据库会一致保持readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高 </li>
</ol>
</li>
</ul>
<h3 id="业务更新不只是增删改数据（DML，还有可能是加字段等修改表结构的操作（DDL）。-不论哪种方法，一个库被全局锁上以后，要对里面任何一个表做加字段操作，都会被锁住。"><a href="#业务更新不只是增删改数据（DML，还有可能是加字段等修改表结构的操作（DDL）。-不论哪种方法，一个库被全局锁上以后，要对里面任何一个表做加字段操作，都会被锁住。" class="headerlink" title="业务更新不只是增删改数据（DML，还有可能是加字段等修改表结构的操作（DDL）。 不论哪种方法，一个库被全局锁上以后，要对里面任何一个表做加字段操作，都会被锁住。"></a>业务更新不只是增删改数据（DML，还有可能是加字段等修改表结构的操作（DDL）。 不论哪种方法，一个库被全局锁上以后，要对里面任何一个表做加字段操作，都会被锁住。</h3><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>表锁</li>
<li>元数据锁（meta data lock, MDL）</li>
</ul>
<h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><ul>
<li>语法：lock tables.. read/write</li>
<li>和FTWRL 类似， 可以用unlock tables z主动释放锁， 也可以在客户端断开的时候自动释放。需要注意的是， lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</li>
<li>举例： 如果在某个线程A中执行lock tables t1 read, t2 write; 则其他线程写t1 ， 读写t2 的语句都会被阻塞。 同时， 线程A在执行unlock tables 之前， 也只能执行读t1、读写t2 的操作。连写t1 都不允许，自然也不能访问其他表</li>
<li>还未出现更细粒度的锁的时候，表锁是最常用的处理并发方式。而对于InnoDB 这种支持行锁的引擎， 一般不是lock tables 命令来控制并发。</li>
</ul>
<h3 id="元数据锁（MDL）"><a href="#元数据锁（MDL）" class="headerlink" title="元数据锁（MDL）"></a>元数据锁（MDL）</h3><ul>
<li>不需要显式使用，在访问一个表的时候会被自动加上。</li>
<li>作用： 保证读写的正确性。 如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做了变更，删了一行，那么查询线程拿到的结果跟表结构对不上， 肯定是不行的</li>
<li><p>MySQL 5.5 版本引入MDL， 当对一个表做增删改查操作的时候，加MDL 读锁； 当要对表做结构变更操作的时候，加MDL 写锁。</p>
<ul>
<li>读锁之间不互斥， 因此可以有多个线程同时对一张表增删改查</li>
<li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。 因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才开始执行</li>
</ul>
</li>
<li><p>例子</p>
<ul>
<li>MDL 锁是系统默认会加的，但不能忽略例子中的机制</li>
<li>给一个表加字段，或者修改字段，或者加索引， 需要扫描全表的数据。 对于大表，可能会对线上服务造成影响。 但是实际上，即使小表，操作不慎也会出问题</li>
<li><p>假设t 是一个小表（环境是MySQL5.6）， 图MDL</p>
<ul>
<li>可以看到session A 先启动， 这时候会对表t加一个MDL读锁</li>
<li>由于session B需要的也是MDL 读锁，因此可以正常运运行</li>
<li>session C 会被blocked， 因为session A 的MDL 读锁还没有释放， 而session C 需要MDL 写锁， 因此只能被阻塞</li>
<li>如果只有session C 自己被阻塞还没什么关系，但是之后所有要在表t 上新申请MDL 读锁的请求也会被session C 阻塞。因为， 所有对表的增删改查操作都需要先申请MDL 读锁，就都被锁住， 等于这个表现在完全不可读写了</li>
<li>如果某个表上的查询语句频繁， 而且客户端有重试机制， 超时后会再起一个新session 再请求，这个库的线程很快会爆满</li>
</ul>
</li>
</ul>
</li>
<li><p>事务中的MDL 锁， 在语句执行开始时的申请， 但是语句结束后并不会马上释放，会等到整个事务提交后再释放</p>
</li>
<li><p>如何安全地给小表加字段</p>
<ul>
<li>首先要解决长事务， 事务不提交，就会一直占着MDL 锁。 在MySQL的 information_schema库的innodb_trx 表中， 可以查询到当前执行中的事务。</li>
<li>若要做DDL变更的表刚好有长事务在执行， 要考虑先暂停DDL， 或者kill掉这个长事务。</li>
<li>但考虑另外的场景，需要变更的表是一个热点表， 虽然数据量不大， 但请求很频繁。 且不得不加字段， 如何执行。</li>
<li>kill 未必管用，比较理想的机制： 在alter table 语句里面设定等待时间，如果在指定时间内能够拿到MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。然后开发人员或者DBA 再重试执行命令重复此过程。</li>
<li><p>MariaDB 已经合并AliSQL 这个功能， 所以这两个开源分支目前都支持DDL NOWAIT/WAIT n这个语法</p>
<ul>
<li>alter table tbl_name NOWAIT add column ….</li>
<li>Alter table tbl_name WAIT N add column</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="全局锁-1"><a href="#全局锁-1" class="headerlink" title="全局锁"></a>全局锁</h3><ul>
<li>用途： 逻辑备份中</li>
<li>如库全是InnoDB, 可选择 -single-transaction 参数</li>
</ul>
<h3 id="表锁-1"><a href="#表锁-1" class="headerlink" title="表锁"></a>表锁</h3><ul>
<li>用途： 数据库引擎不支持行锁的时候才被用到</li>
<li><p>如果程序里有lock tables 这样的语句， 如何做？</p>
<ul>
<li>要么是系统还是MylSAM 这类不支持事务的引擎， 需要升级换引擎</li>
<li>引擎升级，代码没升级，把lock tables 和unlock tables 改成begin和commit</li>
</ul>
</li>
<li><p>MDL 直到事务提交才释放，表变更需要注意，</p>
<ul>
<li>设置超时等待时间，然后循环提交</li>
</ul>
</li>
</ul>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>备份一般都会再备份库上执行，再用-single-transaction 方法做逻辑备份的过程Hon个如果主库的一个小表做了DDL， 比如给一个表上加了一列。这时候备库看到的现象是什么？</li>
</ul>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul>
<li><p>假设DDL是针对表t1的， 那么备份过程中几个关键语句异常如下</p>
<ul>
<li>Q1： SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</li>
<li>Q2： start transaction with consistent snapshot;</li>
<li>/<em> other tables </em>/ Q3: SAVEPOINT sp;</li>
<li>/<em>时刻1</em>/ Q4： show create table ‘t1’;</li>
<li>/<em>时刻2</em>/ Q5： select * from ‘t1’;</li>
<li>/<em>时刻3</em>/ Q6：rollback to savepoint sp;</li>
<li>/<em>时刻4</em>/ /<em>other tables</em>/</li>
</ul>
</li>
<li><p>在备份开始时，为了确保RR（可重复读）隔离级别，再设置一次RR 隔离级别（Q1）</p>
</li>
<li>启动事务， 使用with consistent snapshot 确保这个语句执行完就可以得到一个一致性视图（Q2）</li>
<li>设置一个保存点， 很重要（Q3）</li>
<li>show create 为了拿到表结构(Q4)， 然后正式导数据（Q5）， 回滚到savepoint sp， 作用是释放t1的MDL 锁（Q6）</li>
<li>DDL 从主库传过来的时间按照效果不同，打了四个时刻。 题目设定为小表， 假定到达后，如果开始执行，则很快能够执行完成</li>
</ul>
<h3 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h3><ul>
<li>如果再Q4 语句执行之前到达， 现象： 没有影响， 备份拿到的是DDL 后的表结构</li>
<li>如果再“时刻2到达”， 则表结构被改过， Q5执行的时候，报Table definition has changed, please retry transaction, 现象： mysqldump 终止</li>
<li>如果再“时刻2”和“时刻3”之间到达，mysqldump 占着t1 的MDL 读锁， binlog 被阻塞，现象： 主从延迟， 直到Q6执行完成</li>
<li>从“时刻4”开始，mysqldump 释放了MDL 读锁， 现象： 没有影响， 备份拿到的是DDL 前的表结构</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://echo557.github.io/echoblog.github.io/2019/01/26/MYSQL-Study6/" data-id="cjv2hm8qe000ruwvxxzo3php2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/echoblog.github.io/tags/QA/">QA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MYSQL-Study5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/echoblog.github.io/2019/01/26/MYSQL-Study5/" class="article-date">
  <time datetime="2019-01-26T01:50:15.000Z" itemprop="datePublished">2019-01-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/echoblog.github.io/categories/MYSQL/">MYSQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/echoblog.github.io/2019/01/26/MYSQL-Study5/">索引下</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/echoblog.github.io/2019/01/26/MYSQL-Study5/索引示意图.png" alt="(name,age)索引示意图"><br><img src="/echoblog.github.io/2019/01/26/MYSQL-Study5/InnoDB索引结构.png" alt="InnoDB索引示意图"><br><img src="/echoblog.github.io/2019/01/26/MYSQL-Study5/图三.png" alt="图三"><br><img src="/echoblog.github.io/2019/01/26/MYSQL-Study5/图四.png" alt="图四"><br><img src="/echoblog.github.io/2019/01/26/MYSQL-Study5/索引（下）.png" alt="索引（下）"></p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h4 id="如果执行select-from-T-where-k-between-3-and-5-需要执行几次树的搜索操作，-会扫描多少行？"><a href="#如果执行select-from-T-where-k-between-3-and-5-需要执行几次树的搜索操作，-会扫描多少行？" class="headerlink" title="如果执行select * from T where k between 3 and 5, 需要执行几次树的搜索操作， 会扫描多少行？"></a>如果执行select * from T where k between 3 and 5, 需要执行几次树的搜索操作， 会扫描多少行？</h4><h4 id="初始化语句：-create-table-T-ID-int-primary-key-k-int-not-null-default-0-s-varchar-16-not-null-default-‘’-indec-k-k-engine-InnoDB"><a href="#初始化语句：-create-table-T-ID-int-primary-key-k-int-not-null-default-0-s-varchar-16-not-null-default-‘’-indec-k-k-engine-InnoDB" class="headerlink" title="初始化语句： create table T(ID int primary key, k int not null default 0, s varchar(16) not null default ‘’, indec k(k)) engine = InnoDB;"></a>初始化语句： create table T(ID int primary key, k int not null default 0, s varchar(16) not null default ‘’, indec k(k)) engine = InnoDB;</h4><h4 id="insert-into-T-values-100-1-‘aa’-200-2-’bb’-300-3-’cc’-500-5-’ee’-600-6-’ff’-700-7-’gg’"><a href="#insert-into-T-values-100-1-‘aa’-200-2-’bb’-300-3-’cc’-500-5-’ee’-600-6-’ff’-700-7-’gg’" class="headerlink" title="insert into T values(100,1, ‘aa’),(200,2,’bb’),(300,3,’cc’),(500,5,’ee’),(600,6,’ff’),(700,7,’gg’);"></a>insert into T values(100,1, ‘aa’),(200,2,’bb’),(300,3,’cc’),(500,5,’ee’),(600,6,’ff’),(700,7,’gg’);</h4><h3 id="SQL执行流程"><a href="#SQL执行流程" class="headerlink" title="SQL执行流程"></a>SQL执行流程</h3><ul>
<li>在k索引树上找到k=3的记录，取得ID=300</li>
<li>再到ID索引树查到ID=300对应的R3</li>
<li>在k索引树取下一个值k=5， 取得ID=500</li>
<li>再回到ID 索引树查到ID=500对应的R4</li>
<li>在k索引树取下一个值k=6， 不满足条件，循环结束</li>
</ul>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><ul>
<li>如果执行语句select ID from T where k between 3 and 5， 这时候只需要查ID的值， 而ID 的值已经在k索引树上，因此可以直接提供查询结果，不需要回表。在这个查询里面，索引k已经“覆盖了”我们的查询需求，称为覆盖索引</li>
<li>需要注意的是， 在引擎内部使用覆盖索引在索引k上其实读了3个记录，R3~R5(对应的索引k上的记录项)，但是对于mysql 的server 层来说，它就是找引擎拿到两条记录，因此mysql 认为扫描行数是2</li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>减少树的搜索次数， 显著提升查询性能， 所以使用覆盖索引是一个常用的性能优化手段</li>
</ul>
<h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><ul>
<li>在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？</li>
<li>Create table ‘tuser’(‘id’ int(11) not null, ‘id_card’ varchar(32) default null, ‘name’ varchar(32) default null, ‘age’ int(11) default null, ‘ismale’ tinyint(1) default null, primary key (‘id’), key ‘id_card’ (‘id_card’), key ‘name_age’ (‘name’, ‘age’) ) ENGINE = InnoDB</li>
<li>根据身份证号查询市民信息的需求，我们只需要在身份证号字段上建立索引就够，在建立一个（身份证，姓名）的联合索引，岂不是浪费空间？</li>
<li>如果现在有一个高频请求，要根据身份证号查询姓名，这个联合索引就有意义。它可以在高频请求上用到覆盖索引， 不在需要需要回表查正航记录</li>
</ul>
<h2 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h2><h3 id="引子-1"><a href="#引子-1" class="headerlink" title="引子"></a>引子</h3><ul>
<li>B+树这种索引结构，可以利用索引的“最左前缀”， 来定位记录</li>
<li>如（name,age）索引示意图， 可以看到索引项是按照索引定义里面出现的字段顺序排序的。</li>
<li>当逻辑需求是查到所有名字是“张三”时，可以快速定位到ID4， 然后遍历得到所有需要的结果</li>
<li>如果要查询所有名字第一个字是“张”， SQL 语句就是“where name like ‘张%’”。此时，可以查到第一个符合条件的记录是ID3， 然后向后遍历，直到不满足条件为止</li>
</ul>
<h3 id="讨论-1"><a href="#讨论-1" class="headerlink" title="讨论"></a>讨论</h3><ul>
<li>在建立联合索引时， 如何安排索引内的字段顺序</li>
<li>评估标准： 索引的复用能力。 </li>
<li>第一原则， 如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的</li>
<li>那么，如果既有联合查询，又有基于a,b各自的查询呢？查询条件里面只有b语句，时无法使用(a,b)这个联合索引的，这时候不得不维护另外一个索引，即（a,b）, (b)这两个</li>
<li>空间原则： 如上面的市民表， name 字段大于age 字段，则建议创建一个（name, age）的联合索引和一个（age）的单字段索引</li>
</ul>
<h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><h3 id="引子-2"><a href="#引子-2" class="headerlink" title="引子"></a>引子</h3><ul>
<li>如果满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。 如果不符合最左前缀的部分，怎样处理呢？</li>
<li>如上面的连个索引（name, age）为例。需求： 检索表中“名字第一个字是张，而且年龄是10 的所有男孩”。 SQL：select * from tuser where name like ‘张%’ and age=10 and ismale =1;</li>
<li><p>执行步骤</p>
<ul>
<li>满足第一个条件，找到记录ID=3</li>
<li>在MySQL 5.6 之前，只能从ID3 开始一个个回表，到主键索引上找出数据行，再对比字段值</li>
<li>MYSQL 5.6 引入索引下推优化， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</li>
<li>图三和图四是两个过程的流程图，每一个虚线箭头表示回表一次</li>
<li>图3中，（name,age）索引里面去掉了age的值， 这个过程InnoDB 并不去去看age的值， 值是按顺序把“name第一个字是张”的记录一条条取出来回表。因此需要回表4次。</li>
<li>图4跟图3的区别是： InnoDB 在（name,age）索引内部就判断了age 是否为10， 对于不为10的记录，直接判断并跳过。则需要回表2次</li>
</ul>
</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><h3 id="覆盖索引-1"><a href="#覆盖索引-1" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><ul>
<li>select ID from T where k between 3 and 5</li>
</ul>
<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><ul>
<li>select ID from T where name like ‘张%’</li>
</ul>
<h3 id="索引下推-1"><a href="#索引下推-1" class="headerlink" title="索引下推"></a>索引下推</h3><ul>
<li>select * from tuser where name like ‘张%’ and age=10 and ismale =1;</li>
</ul>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><h3 id="实际上主键索引也是可以使用多个字段的"><a href="#实际上主键索引也是可以使用多个字段的" class="headerlink" title="实际上主键索引也是可以使用多个字段的"></a>实际上主键索引也是可以使用多个字段的</h3><h3 id="如表定义：-create-table-‘geek’-‘a’-int-11-not-null-‘b’-int-11-not-null-‘c’-int-11-not-null-‘d’-int-11-not-null-primary-key-‘a’-‘b’-key-‘c’-‘c’-key-‘ca’-‘c’-’a’-key-‘cb’-‘c’-‘b’-ENGINE-InnoDB"><a href="#如表定义：-create-table-‘geek’-‘a’-int-11-not-null-‘b’-int-11-not-null-‘c’-int-11-not-null-‘d’-int-11-not-null-primary-key-‘a’-‘b’-key-‘c’-‘c’-key-‘ca’-‘c’-’a’-key-‘cb’-‘c’-‘b’-ENGINE-InnoDB" class="headerlink" title="如表定义： create table ‘geek’(‘a’ int(11) not null, ‘b’ int(11) not null, ‘c’ int(11) not null, ‘d’ int(11) not null, primary key (‘a’, ‘b’), key ‘c’ (‘c’), key ‘ca’ (‘c’,’a’), key ‘cb’ (‘c’, ‘b’))ENGINE = InnoDB;"></a>如表定义： create table ‘geek’(‘a’ int(11) not null, ‘b’ int(11) not null, ‘c’ int(11) not null, ‘d’ int(11) not null, primary key (‘a’, ‘b’), key ‘c’ (‘c’), key ‘ca’ (‘c’,’a’), key ‘cb’ (‘c’, ‘b’))ENGINE = InnoDB;</h3><h3 id="这个表需要a-b-做连个主键索引，-但为什么还有‘ca’，‘cb’两个索引呢？"><a href="#这个表需要a-b-做连个主键索引，-但为什么还有‘ca’，‘cb’两个索引呢？" class="headerlink" title="这个表需要a,b 做连个主键索引， 但为什么还有‘ca’，‘cb’两个索引呢？"></a>这个表需要a,b 做连个主键索引， 但为什么还有‘ca’，‘cb’两个索引呢？</h3><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><ul>
<li>主键a,b的聚簇索引组织顺序相当于order by a,b,也就是按a排序， 再按b排序，c 无序</li>
<li>索引ca的组织是先按c排序，再按a排序， 同时记录主键（注意，这里不是ab， 而是只有b。 这个跟索引c的数据是一模一样的</li>
<li>索引cb的组织是先按c排序，再按b排序，同时记录主键a</li>
<li>因此 ca 可以去掉， cb需要保留</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://echo557.github.io/echoblog.github.io/2019/01/26/MYSQL-Study5/" data-id="cjv2hm8qc000nuwvxsgt5mbii" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/echoblog.github.io/tags/QA/">QA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LinuxCommand" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/echoblog.github.io/2019/01/20/LinuxCommand/" class="article-date">
  <time datetime="2019-01-20T13:50:25.000Z" itemprop="datePublished">2019-01-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/echoblog.github.io/categories/Operation-System/">Operation System</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/echoblog.github.io/2019/01/20/LinuxCommand/">Linux Command</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Basic-Command"><a href="#Basic-Command" class="headerlink" title="Basic Command"></a>Basic Command</h3><p>系统信息<br>arch<br>uname -m<br>cat /proc/cpuinfo<br>data</p>
<p>文件搜索<br>find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录<br>find / -user user1 搜索属于用户 ‘user1’ 的文件和目录<br>find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件<br>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://echo557.github.io/echoblog.github.io/2019/01/20/LinuxCommand/" data-id="cjv2hm8pp000auwvxn8f08a81" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/echoblog.github.io/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MYSQL-Study4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/echoblog.github.io/2019/01/07/MYSQL-Study4/" class="article-date">
  <time datetime="2019-01-07T12:46:59.000Z" itemprop="datePublished">2019-01-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/echoblog.github.io/categories/MYSQL/">MYSQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/echoblog.github.io/2019/01/07/MYSQL-Study4/">索引上</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="索引上"><a href="#索引上" class="headerlink" title="索引上"></a>索引上</h3><p>索引是为了提高数据库查询的效率， 就像书的目录一样。</p>
<h4 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h4><p>可以用于提高读写效率的数据结构很多，常见的三种数据结构有： 哈希表、有序数组 和搜索树。<br>区别：</p>
<ol>
<li>哈希表是一种以键值对（key-value）存储数据的结构，我们只需要输入待查找的值key, j就能找到对应的值value。 哈希的思路： 把值放在数组里， 用一个哈希函数<br>把key 换算成一个确定的位置， 然后把value放在数组的这个位置。<br>不可避免地， 多个key值经过hash 函数地转换，会出现同一个值得情况。处理这种情况得一种方法是： 拉出一个链表。<br>如一个需要维护得身份证信息和姓名得表，需要根据身份证号找到对应名字，哈希索引示意图：</li>
</ol>
<p><img src="/echoblog.github.io/2019/01/07/MYSQL-Study4/hash.png" alt="Hash"><br>图中，User2 和User4根据身份证号算出来得值都是N，但是没关系，后面还有个链表。<br>若你要查出ID_card_n2对应得name,step： 将ID_card_n2通过hash function 算出N， 然后顺序遍历，找到user2.</p>
<p>主要注意得是， 图中四个ID_card_n得值并不是递增得，这样得好处是增加新user时速度会很快，只需要往后追加。 缺点是： 因为不是有序，<br>所以哈希索引做区间查询得速度是很慢的。<br>所以，哈希表这种结构适用于只有等值查询的场景。 如Memcached 及其他一些NoSQL 引擎。</p>
<ol start="2">
<li>而有序数组在等值查询和范围查询场景中的性能就都非常优秀。 如下图：<br><img src="/echoblog.github.io/2019/01/07/MYSQL-Study4/order.png" alt="Order"></li>
</ol>
<p>假设身份证号没有重复，此数组就是按照身份证号递增的顺序保存的。这时候要查ID_card_n2 对应的名字， 用二分法就可以很快速得到， 时间复杂度是O(LOG(N)).</p>
<p>同时很显然，这个索引结构支持范围查询。 若要查询身份证号在[ID_card_X, ID_card_Y]区间的User, 可以先用二分法找到ID_card_X(<br>如果不存在ID_card_X， 就找到大于ID_card__X的第一个User)， 然后向右遍历， 直到找到第一个大于ID_card_Y 的身份证号，退出循环。</p>
<p>仅看查询效率，有序数组是最好的数据结构。 但更新需要挪动后面所有记录，成本太高。<br>所以，有序数组索引只适用于静态存储引擎， 那些不再修改的数据。</p>
<ol start="3">
<li>二叉搜索树，同样例子如图：<br><img src="/echoblog.github.io/2019/01/07/MYSQL-Study4/tree.png" alt="Tree"></li>
</ol>
<p>二叉搜索树的特点： 每个节点的左儿子小于父节点， 父节点又小于右儿子。 若要查询ID_card_n2的话， 按照图中搜索顺序就是按照UserA&gt;UserC&gt;UserF&gt;User2此路径<br>得到。 这个时间复杂成都是O（log(N)）。</p>
<p>当然为了维持O（log(N)）的查询复杂度， 就需要平衡二叉树， 为了保证这个，更新时间复杂度也是O（log(N)）。</p>
<p>树可以有二叉， 也可以有多叉。 多叉树就是每个节点有多个儿子，儿子之间大小从左到右递增。二叉树的搜索效率是最高的。但是实际上<br>大多数数据库存储却并不使用二叉树。 原因是： 索引不止存在内存中，还要写到磁盘里。</p>
<p>若一颗100万节点的平衡二叉树，树高20.一次查询可能需要访问20个数据块。在机械硬盘时代，从磁盘随机读一个数据库需要10ms 左右的寻址时间。 对于<br>100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10ms。</p>
<p>为了让一个查询尽量少读磁盘，就必须让查询过程访问尽量少的数据块。所以，应该使用N叉树。这里， N叉树中的N取决于数据块大小。 </p>
<p>以InnoDB 为例， N大概是1200. 树高为4的时候，可以存储1200的3次方个值，为17亿。 考虑到树根的数据块总是在内存中，一个<br>10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3此磁盘。 其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了</p>
<p>N叉树由于读写上的性能优点，以及适配磁盘的访问模式。已经被广泛应用在数据库引擎中。<br>跳表、LSM树等数据结构也被用于引擎设计中。</p>
<p>数据库底层存储核心是基于数据库模型的。<br>在MYSQL 中， 索引是在存储引擎层实现的，所以并没有统一索引标准，即不同才存储引擎的索引工作方式并不一样。</p>
<h3 id="InnoDB索引模型"><a href="#InnoDB索引模型" class="headerlink" title="InnoDB索引模型"></a>InnoDB索引模型</h3><p>在InnoDB中， 表是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。 InnoDB使用了B+树索引模型，<br>所以数据是存储在B+树中的。 每个索引在InnoDB里面对应一颗B+树。<br>若， 我们有一个主键列为ID的值， 表中有字段K， 并且在K 上有索引。<br>建表语句：<br>create table T(<br>id int primary key,<br>k int not null,<br>name varchar(16),<br>index (k))engine = InnoDB;</p>
<p>表中R1-R5的(ID,k)值分别为（100,1）,(200,2),(300,3),(400,4),(500,5)和(600,6)， 两棵树示例如下：<br><img src="/echoblog.github.io/2019/01/07/MYSQL-Study4/InnoDB.png" alt="InnoDB Example"></p>
<p>根据叶子节点的内容，索引类型分为主键索引 和非主键索引。 主键索引的叶子节点存的是整行数据， 在InnoDB里，<br>主键索引也被称为聚簇索引（clustered index）。 非主键索引的叶子节点内容是主键的值。 在InnoDB中，非<br>主键索引也称为二级索引（secondary index）。</p>
<p>基于主键索引和普通索引的查询区别：</p>
<ol>
<li>如果语句是select * from T where ID=500, 即主键查询方式，则只需要搜索ID 这颗B+树。</li>
<li>如果语句是 select * from T where k=5， 即普通索引查询方式，则需要先搜索k索引树， 得到ID 的<br>值为500， 再到ID 索引树搜索一次。 此过程叫回表。</li>
</ol>
<p>因此我们再应用中应尽量使用主键查询。</p>
<h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><p>B+ 树为了索引有序性， 在插入新值得时候需要做必要得维护。<br>以上图为例，如果插入新的行ID 值为700， 则只需要在R5的记录后面插入一个新记录。如果新插入的ID 值为400，<br>就相对麻烦，需要逻辑上挪动后面的数据，空出位置。更糟糕的是，如果R5 所在数据页已经满了，根据B+树的算法，<br>这时候就需要申请一个新的数据页，然后挪动部分数据过去。此过程叫页分裂，这种状况下啊，性能就会受到影响。</p>
<p>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。<br>当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p>
<p>基于上面索引维护过程说明，可以做以下讨论：<br>可能在一些建表规范中见过类似描述， 要求建表语句里一定要有自增主键。那么可以分析以下哪些场景下应该使用自增主键，哪些不该。</p>
<p>自增主键： 自增列上定义的主键，在建表语句中一般定义：NOT NULL PRIMARY KEY AUTO_INCREMENT<br>插入新记录的时候可以不指定ID 值， 系统会获取当前ID最大值加1作为下一条记录的ID 值。<br>即， 自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，<br>都不涉及到挪动其他记录，也不会触及到叶子节点的分裂。</p>
<p>而有业务逻辑的字段做主键则往往不容易保证有序插入，这样写数据成本相对较高。</p>
<p>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证做主键，那么每个二级索引的叶子节点占用约20个字节，如果整型做<br>主键，则只要4个字节，如果长整型(bigint)则是8个字节。</p>
<p>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</p>
<p>所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。</p>
<p>有没有什么场景适合用业务字段直接做主键的呢？ 如：有些业务场景需求是：</p>
<ol>
<li>只有一个索引</li>
<li>该索引必须是唯一索引<br>KV场景</li>
</ol>
<p>需要尽量使用主键查询原则，直接将索引设置为主键，可以避免每次搜索两棵树。</p>
<h4 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h4><p>通过两个alter 语句重建索引k,以及通过两个alter 语句重建主键索引是否合理。</p>
<p>为什么要重建索引？<br>索引可能因为删除，或者页分裂等原因，导致数据页有空洞， 重建索引的过程会创建一个新的索引，把数据按顺序插入，可以让页面利用率最高。</p>
<p>重建索引k的做法是合理的，可以达到省空间的目的。但是，重建主键的过程不合理。 不论是删除主键还是创建主键，都会将整个表重建。<br>所以连着执行两个语句，第一个语句就会白做。所以可以用语句代替： alter table T engine=InnoDB</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://echo557.github.io/echoblog.github.io/2019/01/07/MYSQL-Study4/" data-id="cjv2hm8qa000luwvx05e04zyh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/echoblog.github.io/tags/QA/">QA</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/echoblog.github.io/page/7/">&laquo; Prev</a><a class="page-number" href="/echoblog.github.io/">1</a><span class="space">&hellip;</span><a class="page-number" href="/echoblog.github.io/page/6/">6</a><a class="page-number" href="/echoblog.github.io/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/echoblog.github.io/page/9/">9</a><a class="page-number" href="/echoblog.github.io/page/10/">10</a><a class="extend next" rel="next" href="/echoblog.github.io/page/9/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/AutoTesting/">AutoTesting</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/English/">English</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/HTTP/">HTTP</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/Jmeter/">Jmeter</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/Learning/">Learning</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/MYSQL/">MYSQL</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/Operation-System/">Operation System</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/Performance/">Performance</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/SQA/">SQA</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/Tools/">Tools</a></li><li class="category-list-item"><a class="category-list-link" href="/echoblog.github.io/categories/Trouble-shooting/">Trouble-shooting</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/Automation/">Automation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/English/">English</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/Machine-Leaning/">Machine Leaning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/Performance/">Performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/Protocol/">Protocol</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/QA/">QA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/SQA/">SQA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/Scripts/">Scripts</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/TestingMethod/">TestingMethod</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/Tools/">Tools</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/Trouble-Shooting/">Trouble Shooting</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/TroubleShooting/">TroubleShooting</a></li><li class="tag-list-item"><a class="tag-list-link" href="/echoblog.github.io/tags/View/">View</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/echoblog.github.io/tags/Automation/" style="font-size: 10px;">Automation</a> <a href="/echoblog.github.io/tags/English/" style="font-size: 10px;">English</a> <a href="/echoblog.github.io/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/echoblog.github.io/tags/Machine-Leaning/" style="font-size: 10px;">Machine Leaning</a> <a href="/echoblog.github.io/tags/Performance/" style="font-size: 12.5px;">Performance</a> <a href="/echoblog.github.io/tags/Protocol/" style="font-size: 15px;">Protocol</a> <a href="/echoblog.github.io/tags/QA/" style="font-size: 20px;">QA</a> <a href="/echoblog.github.io/tags/SQA/" style="font-size: 12.5px;">SQA</a> <a href="/echoblog.github.io/tags/Scripts/" style="font-size: 17.5px;">Scripts</a> <a href="/echoblog.github.io/tags/TestingMethod/" style="font-size: 10px;">TestingMethod</a> <a href="/echoblog.github.io/tags/Tools/" style="font-size: 10px;">Tools</a> <a href="/echoblog.github.io/tags/Trouble-Shooting/" style="font-size: 10px;">Trouble Shooting</a> <a href="/echoblog.github.io/tags/TroubleShooting/" style="font-size: 10px;">TroubleShooting</a> <a href="/echoblog.github.io/tags/View/" style="font-size: 10px;">View</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/echoblog.github.io/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/echoblog.github.io/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/echoblog.github.io/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/echoblog.github.io/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/echoblog.github.io/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/echoblog.github.io/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/echoblog.github.io/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/echoblog.github.io/2019/04/29/httpProtocol3/">HTTP-Protocol解析</a>
          </li>
        
          <li>
            <a href="/echoblog.github.io/2019/04/29/httpProtocol2/">HTTP-Protocol基础</a>
          </li>
        
          <li>
            <a href="/echoblog.github.io/2019/04/29/httpProtocol/">HTTP-Protocol概要</a>
          </li>
        
          <li>
            <a href="/echoblog.github.io/2019/04/26/Performance3/">如何估计性能测试并发量</a>
          </li>
        
          <li>
            <a href="/echoblog.github.io/2019/04/26/python11/">appium API</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Ying<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/echoblog.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/echoblog.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/echoblog.github.io/fancybox/jquery.fancybox.css">
  <script src="/echoblog.github.io/fancybox/jquery.fancybox.pack.js"></script>


<script src="/echoblog.github.io/js/script.js"></script>



  </div>
</body>
</html>